/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ModalFormPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian16 = require("obsidian");

// src/exampleModalDefinition.ts
var exampleModalDefinition = {
  title: "Example form",
  name: "example-form",
  version: "1",
  fields: [
    {
      name: "Name",
      description: "It is named how?",
      input: { type: "text" }
    },
    {
      name: "age",
      label: "Age",
      description: "How old",
      input: { type: "number" }
    },
    {
      name: "dateOfBirth",
      label: "Date of Birth",
      description: "When were you born?",
      input: { type: "date" }
    },
    {
      name: "timeOfDay",
      label: "Time of day",
      description: "The time you can do this",
      input: { type: "time" }
    },
    {
      name: "is_family",
      label: "Is family",
      description: "If it is part of the family",
      input: { type: "toggle" }
    },
    {
      name: "favorite_book",
      label: "Favorite book",
      description: "Pick one",
      input: { type: "note", folder: "Books" }
    },
    {
      name: "multi_example",
      label: "Multi select folder",
      description: "Allows to pick many notes from a folder",
      input: { type: "multiselect", source: "notes", folder: "Books" }
    },
    {
      name: "multi_example_2",
      label: "Multi select fixed",
      description: "Allows to pick many notes from a fixed list",
      input: { type: "multiselect", source: "fixed", multi_select_options: ["Android", "iOS", "Windows", "MacOS", "Linux", "Solaris", "MS2"] }
    },
    {
      name: "multi_select_dataview",
      label: "Multi select dataview",
      description: "Allows to pick several values from a dv query",
      input: { type: "multiselect", source: "dataview", query: 'dv.pages("#person").map(p => p.file.name)' }
    },
    {
      name: "best_fried",
      label: "Best friend",
      description: "Pick one",
      input: {
        type: "select",
        source: "notes",
        folder: "People"
      }
    },
    {
      name: "dataview_example",
      label: "Dataview example",
      description: "Only people matching the dataview query will be shown",
      input: {
        type: "dataview",
        query: 'dv.pages("#person").filter(p => p.age < 30).map(p => p.file.name)'
      }
    },
    {
      name: "friendship_level",
      label: "Friendship level",
      description: "How good friends are you?",
      input: {
        type: "slider",
        min: 0,
        max: 10
      }
    },
    {
      name: "favorite_meal",
      label: "Favorite meal",
      description: "Pick one option",
      input: {
        type: "select",
        source: "fixed",
        options: [
          { value: "pizza", label: "\u{1F355} Pizza" },
          { value: "pasta", label: "\u{1F35D} Pasta" },
          { value: "burger", label: "\u{1F354} Burger" },
          { value: "salad", label: "\u{1F957} Salad" },
          { value: "steak", label: "\u{1F969} Steak" },
          { value: "sushi", label: "\u{1F363} Sushi" },
          { value: "ramen", label: "\u{1F35C} Ramen" },
          { value: "tacos", label: "\u{1F32E} Tacos" },
          { value: "fish", label: "\u{1F41F} Fish" },
          { value: "chicken", label: "\u{1F357} Chicken" }
        ]
      }
    },
    {
      name: "some notes",
      label: "Multi line notes",
      description: "Put your thouhts here",
      input: {
        type: "textarea"
      }
    }
  ]
};

// src/ModalFormSettingTab.ts
var import_obsidian = require("obsidian");

// node_modules/valibot/dist/index.js
var ValiError = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(issues) {
    super(issues[0].message);
    __publicField(this, "issues");
    this.name = "ValiError";
    this.issues = issues;
  }
};
var BrandSymbol = Symbol("brand");
function coerce(schema, action) {
  return {
    ...schema,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      return schema._parse(action(input), info);
    }
  };
}
function getIssues(issues) {
  return { issues };
}
function getOutput(output) {
  return { output };
}
function getIssue(info, issue) {
  return {
    reason: info == null ? void 0 : info.reason,
    validation: issue.validation,
    origin: (info == null ? void 0 : info.origin) || "value",
    message: issue.message,
    input: issue.input,
    path: issue.path,
    abortEarly: info == null ? void 0 : info.abortEarly,
    abortPipeEarly: info == null ? void 0 : info.abortPipeEarly,
    skipPipe: info == null ? void 0 : info.skipPipe
  };
}
function getPipeInfo(info, reason) {
  return {
    reason,
    origin: info == null ? void 0 : info.origin,
    abortEarly: info == null ? void 0 : info.abortEarly,
    abortPipeEarly: info == null ? void 0 : info.abortPipeEarly,
    skipPipe: info == null ? void 0 : info.skipPipe
  };
}
function executePipe(input, pipe3, parseInfo, reason) {
  if (!pipe3 || !pipe3.length || (parseInfo == null ? void 0 : parseInfo.skipPipe)) {
    return getOutput(input);
  }
  let pipeInfo;
  let issues;
  let output = input;
  for (const action of pipe3) {
    const result = action(output);
    if (result.issues) {
      pipeInfo = pipeInfo || getPipeInfo(parseInfo, reason);
      for (const issueInfo of result.issues) {
        const issue = getIssue(pipeInfo, issueInfo);
        issues ? issues.push(issue) : issues = [issue];
      }
      if (pipeInfo.abortEarly || pipeInfo.abortPipeEarly) {
        break;
      }
    } else {
      output = result.output;
    }
  }
  return issues ? getIssues(issues) : getOutput(output);
}
function getDefaultArgs(arg1, arg2) {
  return Array.isArray(arg1) ? [void 0, arg1] : [arg1, arg2];
}
function getErrorMessage(error) {
  return typeof error === "function" ? error() : error;
}
function getPipeIssues(validation, error, input) {
  return getIssues([
    {
      validation,
      message: getErrorMessage(error),
      input
    }
  ]);
}
function getSchemaIssues(info, reason, validation, error, input, issues) {
  return {
    issues: [
      {
        reason,
        validation,
        origin: (info == null ? void 0 : info.origin) || "value",
        message: getErrorMessage(error),
        input,
        issues,
        abortEarly: info == null ? void 0 : info.abortEarly,
        abortPipeEarly: info == null ? void 0 : info.abortPipeEarly,
        skipPipe: info == null ? void 0 : info.skipPipe
      }
    ]
  };
}
function is(schema, input) {
  return !schema._parse(input, { abortEarly: true }).issues;
}
function array(item, arg2, arg3) {
  const [error, pipe3] = getDefaultArgs(arg2, arg3);
  return {
    /**
     * The schema type.
     */
    schema: "array",
    /**
     * The array item schema.
     */
    array: { item },
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (!Array.isArray(input)) {
        return getSchemaIssues(
          info,
          "type",
          "array",
          error || "Invalid type",
          input
        );
      }
      let issues;
      const output = [];
      for (let key = 0; key < input.length; key++) {
        const value2 = input[key];
        const result = item._parse(value2, info);
        if (result.issues) {
          const pathItem = {
            schema: "array",
            input,
            key,
            value: value2
          };
          for (const issue of result.issues) {
            if (issue.path) {
              issue.path.unshift(pathItem);
            } else {
              issue.path = [pathItem];
            }
            issues == null ? void 0 : issues.push(issue);
          }
          if (!issues) {
            issues = result.issues;
          }
          if (info == null ? void 0 : info.abortEarly) {
            break;
          }
        } else {
          output.push(result.output);
        }
      }
      return issues ? getIssues(issues) : executePipe(output, pipe3, info, "array");
    }
  };
}
function enumType(enumValue, error) {
  return {
    /**
     * The schema type.
     */
    schema: "enum",
    /**
     * The enum value.
     */
    enum: enumValue,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (!enumValue.includes(input)) {
        return getSchemaIssues(
          info,
          "type",
          "enum",
          error || "Invalid type",
          input
        );
      }
      return getOutput(input);
    }
  };
}
function literal(literal2, error) {
  return {
    /**
     * The schema type.
     */
    schema: "literal",
    /**
     * The literal value.
     */
    literal: literal2,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (input !== literal2) {
        return getSchemaIssues(
          info,
          "type",
          "literal",
          error || "Invalid type",
          input
        );
      }
      return getOutput(input);
    }
  };
}
function number(arg1, arg2) {
  const [error, pipe3] = getDefaultArgs(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "number",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (typeof input !== "number" || Number.isNaN(input)) {
        return getSchemaIssues(
          info,
          "type",
          "number",
          error || "Invalid type",
          input
        );
      }
      return executePipe(input, pipe3, info, "number");
    }
  };
}
function object(object2, arg2, arg3) {
  const [error, pipe3] = getDefaultArgs(arg2, arg3);
  let cachedEntries;
  return {
    /**
     * The schema type.
     */
    schema: "object",
    /**
     * The object schema.
     */
    object: object2,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (!input || typeof input !== "object") {
        return getSchemaIssues(
          info,
          "type",
          "object",
          error || "Invalid type",
          input
        );
      }
      cachedEntries = cachedEntries || Object.entries(object2);
      let issues;
      const output = {};
      for (const [key, schema] of cachedEntries) {
        const value2 = input[key];
        const result = schema._parse(value2, info);
        if (result.issues) {
          const pathItem = {
            schema: "object",
            input,
            key,
            value: value2
          };
          for (const issue of result.issues) {
            if (issue.path) {
              issue.path.unshift(pathItem);
            } else {
              issue.path = [pathItem];
            }
            issues == null ? void 0 : issues.push(issue);
          }
          if (!issues) {
            issues = result.issues;
          }
          if (info == null ? void 0 : info.abortEarly) {
            break;
          }
        } else if (result.output !== void 0 || key in input) {
          output[key] = result.output;
        }
      }
      return issues ? getIssues(issues) : executePipe(
        output,
        pipe3,
        info,
        "object"
      );
    }
  };
}
function optional(wrapped, default_) {
  return {
    /**
     * The schema type.
     */
    schema: "optional",
    /**
     * The wrapped schema.
     */
    wrapped,
    /**
     * The default value.
     */
    get default() {
      return typeof default_ === "function" ? default_() : default_;
    },
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      const value2 = input === void 0 ? this.default : input;
      if (value2 === void 0) {
        return getOutput(value2);
      }
      return wrapped._parse(value2, info);
    }
  };
}
function string(arg1, arg2) {
  const [error, pipe3] = getDefaultArgs(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "string",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (typeof input !== "string") {
        return getSchemaIssues(
          info,
          "type",
          "string",
          error || "Invalid type",
          input
        );
      }
      return executePipe(input, pipe3, info, "string");
    }
  };
}
function union(union22, error) {
  return {
    /**
     * The schema type.
     */
    schema: "union",
    /**
     * The union schema.
     */
    union: union22,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      let issues;
      let output;
      for (const schema of union22) {
        const result = schema._parse(input, info);
        if (result.issues) {
          if (issues) {
            for (const issue of result.issues) {
              issues.push(issue);
            }
          } else {
            issues = result.issues;
          }
        } else {
          output = [result.output];
          break;
        }
      }
      return output ? getOutput(output[0]) : getSchemaIssues(
        info,
        "type",
        "union",
        error || "Invalid type",
        input,
        issues
      );
    }
  };
}
function unknown(pipe3 = []) {
  return {
    /**
     * The schema type.
     */
    schema: "unknown",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      return executePipe(input, pipe3, info, "unknown");
    }
  };
}
function merge(schemas, arg2, arg3) {
  const [error, pipe3] = getDefaultArgs(arg2, arg3);
  return object(
    schemas.reduce(
      (object2, schemas2) => ({ ...object2, ...schemas2.object }),
      {}
    ),
    error,
    pipe3
  );
}
function parse(schema, input, info) {
  const result = schema._parse(input, info);
  if (result.issues) {
    throw new ValiError(result.issues);
  }
  return result.output;
}
function passthrough(schema) {
  return {
    ...schema,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      const result = schema._parse(input, info);
      return !result.issues ? getOutput({ ...input, ...result.output }) : result;
    }
  };
}
function safeParse(schema, input, info) {
  const result = schema._parse(input, info);
  return result.issues ? {
    success: false,
    error: new ValiError(result.issues),
    issues: result.issues
  } : {
    success: true,
    data: result.output,
    output: result.output
  };
}
function toTrimmed() {
  return (input) => getOutput(input.trim());
}
function minLength(requirement, error) {
  return (input) => input.length < requirement ? getPipeIssues("min_length", error || "Invalid length", input) : getOutput(input);
}

// node_modules/fp-ts/es6/function.js
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function identity(a) {
  return a;
}
function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {
  switch (arguments.length) {
    case 1:
      return ab;
    case 2:
      return function() {
        return bc(ab.apply(this, arguments));
      };
    case 3:
      return function() {
        return cd(bc(ab.apply(this, arguments)));
      };
    case 4:
      return function() {
        return de(cd(bc(ab.apply(this, arguments))));
      };
    case 5:
      return function() {
        return ef(de(cd(bc(ab.apply(this, arguments)))));
      };
    case 6:
      return function() {
        return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
      };
    case 7:
      return function() {
        return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
      };
    case 8:
      return function() {
        return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
      };
    case 9:
      return function() {
        return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
      };
  }
  return;
}
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default: {
      var ret = arguments[0];
      for (var i = 1; i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}
var dual = function(arity, body) {
  var isDataFirst = typeof arity === "number" ? function(args) {
    return args.length >= arity;
  } : arity;
  return function() {
    var args = Array.from(arguments);
    if (isDataFirst(arguments)) {
      return body.apply(this, args);
    }
    return function(self) {
      return body.apply(void 0, __spreadArray([self], args, false));
    };
  };
};

// node_modules/fp-ts/es6/internal.js
var isSome = function(fa) {
  return fa._tag === "Some";
};
var none = { _tag: "None" };
var some = function(a) {
  return { _tag: "Some", value: a };
};
var isLeft = function(ma) {
  return ma._tag === "Left";
};
var isRight = function(ma) {
  return ma._tag === "Right";
};
var left = function(e) {
  return { _tag: "Left", left: e };
};
var right = function(a) {
  return { _tag: "Right", right: a };
};
var isNonEmpty = function(as4) {
  return as4.length > 0;
};
var has = Object.prototype.hasOwnProperty;

// node_modules/fp-ts/es6/Functor.js
function as(F) {
  return function(self, b) {
    return F.map(self, function() {
      return b;
    });
  };
}
function asUnit(F) {
  var asM = as(F);
  return function(self) {
    return asM(self, void 0);
  };
}

// node_modules/fp-ts/es6/Chain.js
function tap(M) {
  return function(first, f) {
    return M.chain(first, function(a) {
      return M.map(f(a), function() {
        return a;
      });
    });
  };
}

// node_modules/fp-ts/es6/FromEither.js
function fromEitherK(F) {
  return function(f) {
    return flow(f, F.fromEither);
  };
}
function tapEither(F, M) {
  var fromEither2 = fromEitherK(F);
  var tapM = tap(M);
  return function(self, f) {
    return tapM(self, fromEither2(f));
  };
}

// node_modules/fp-ts/es6/Separated.js
var separated = function(left3, right3) {
  return { left: left3, right: right3 };
};

// node_modules/fp-ts/es6/Either.js
var left2 = left;
var right2 = right;
var flatMap = /* @__PURE__ */ dual(2, function(ma, f) {
  return isLeft2(ma) ? ma : f(ma.right);
});
var _map = function(fa, f) {
  return pipe(fa, map(f));
};
var _ap = function(fab, fa) {
  return pipe(fab, ap(fa));
};
var URI = "Either";
var map = function(f) {
  return function(fa) {
    return isLeft2(fa) ? fa : right2(f(fa.right));
  };
};
var Functor = {
  URI,
  map: _map
};
var as2 = dual(2, as(Functor));
var asUnit2 = asUnit(Functor);
var apW = function(fa) {
  return function(fab) {
    return isLeft2(fab) ? fab : isLeft2(fa) ? fa : right2(fab.right(fa.right));
  };
};
var ap = apW;
var Chain = {
  URI,
  map: _map,
  ap: _ap,
  chain: flatMap
};
var bimap = function(f, g) {
  return function(fa) {
    return isLeft2(fa) ? left2(f(fa.left)) : right2(g(fa.right));
  };
};
var mapLeft = function(f) {
  return function(fa) {
    return isLeft2(fa) ? left2(f(fa.left)) : fa;
  };
};
var FromEither = {
  URI,
  fromEither: identity
};
var isLeft2 = isLeft;
var isRight2 = isRight;
var getOrElseW = function(onLeft) {
  return function(ma) {
    return isLeft2(ma) ? onLeft(ma.left) : ma.right;
  };
};
var getOrElse = getOrElseW;
var tap2 = /* @__PURE__ */ dual(2, tap(Chain));
var _FromEither = {
  fromEither: FromEither.fromEither
};
var orElseW = function(onLeft) {
  return function(ma) {
    return isLeft2(ma) ? onLeft(ma.left) : ma;
  };
};
var orElse = orElseW;
var fromNullable = function(e) {
  return function(a) {
    return a == null ? left2(e) : right2(a);
  };
};
var tryCatch = function(f, onThrow) {
  try {
    return right2(f());
  } catch (e) {
    return left2(onThrow(e));
  }
};
var tryCatchK = function(f, onThrow) {
  return function() {
    var a = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      a[_i] = arguments[_i];
    }
    return tryCatch(function() {
      return f.apply(void 0, a);
    }, onThrow);
  };
};
var chainW = flatMap;

// node_modules/fp-ts/es6/Magma.js
var concatAll = function(M) {
  return function(startWith) {
    return function(as4) {
      return as4.reduce(function(a, acc) {
        return M.concat(a, acc);
      }, startWith);
    };
  };
};

// node_modules/fp-ts/es6/Semigroup.js
var constant = function(a) {
  return {
    concat: function() {
      return a;
    }
  };
};
var concatAll2 = concatAll;
var semigroupVoid = constant(void 0);

// node_modules/fp-ts/es6/ReadonlyNonEmptyArray.js
var isNonEmpty2 = isNonEmpty;

// node_modules/fp-ts/es6/NonEmptyArray.js
var isNonEmpty3 = function(as4) {
  return as4.length > 0;
};
var fromArray = function(as4) {
  return isNonEmpty3(as4) ? some(as4) : none;
};

// node_modules/fp-ts/es6/ReadonlyArray.js
function findFirst(predicate) {
  return function(as4) {
    for (var i = 0; i < as4.length; i++) {
      if (predicate(as4[i])) {
        return some(as4[i]);
      }
    }
    return none;
  };
}
var findFirstMap = function(f) {
  return function(as4) {
    for (var i = 0; i < as4.length; i++) {
      var out = f(as4[i]);
      if (isSome(out)) {
        return out;
      }
    }
    return none;
  };
};

// node_modules/fp-ts/es6/Array.js
function findFirst2(predicate) {
  return findFirst(predicate);
}
var findFirstMap2 = findFirstMap;
var map2 = function(f) {
  return function(fa) {
    return fa.map(function(a) {
      return f(a);
    });
  };
};
var filter = function(predicate) {
  return function(as4) {
    return as4.filter(predicate);
  };
};
var partition = function(predicate) {
  return partitionWithIndex(function(_, a) {
    return predicate(a);
  });
};
var partitionWithIndex = function(predicateWithIndex) {
  return function(as4) {
    var left3 = [];
    var right3 = [];
    for (var i = 0; i < as4.length; i++) {
      var b = as4[i];
      if (predicateWithIndex(i, b)) {
        right3.push(b);
      } else {
        left3.push(b);
      }
    }
    return separated(left3, right3);
  };
};
var partitionMap = function(f) {
  return partitionMapWithIndex(function(_, a) {
    return f(a);
  });
};
var partitionMapWithIndex = function(f) {
  return function(fa) {
    var left3 = [];
    var right3 = [];
    for (var i = 0; i < fa.length; i++) {
      var e = f(i, fa[i]);
      if (e._tag === "Left") {
        left3.push(e.left);
      } else {
        right3.push(e.right);
      }
    }
    return separated(left3, right3);
  };
};

// node_modules/fp-ts/es6/Option.js
var none2 = none;
var some2 = some;
var getRight = function(ma) {
  return ma._tag === "Left" ? none2 : some2(ma.right);
};
var _map2 = function(fa, f) {
  return pipe(fa, map3(f));
};
var _ap2 = function(fab, fa) {
  return pipe(fab, ap2(fa));
};
var URI2 = "Option";
var map3 = function(f) {
  return function(fa) {
    return isNone2(fa) ? none2 : some2(f(fa.value));
  };
};
var Functor2 = {
  URI: URI2,
  map: _map2
};
var as3 = dual(2, as(Functor2));
var asUnit3 = asUnit(Functor2);
var ap2 = function(fa) {
  return function(fab) {
    return isNone2(fab) ? none2 : isNone2(fa) ? none2 : some2(fab.value(fa.value));
  };
};
var flatMap2 = /* @__PURE__ */ dual(2, function(ma, f) {
  return isNone2(ma) ? none2 : f(ma.value);
});
var Chain2 = {
  URI: URI2,
  map: _map2,
  ap: _ap2,
  chain: flatMap2
};
var orElse2 = dual(2, function(self, that) {
  return isNone2(self) ? that() : self;
});
var fromEither = getRight;
var FromEither2 = {
  URI: URI2,
  fromEither
};
var isNone2 = function(fa) {
  return fa._tag === "None";
};
var getOrElseW2 = function(onNone) {
  return function(ma) {
    return isNone2(ma) ? onNone() : ma.value;
  };
};
var getOrElse2 = getOrElseW2;
var tap3 = /* @__PURE__ */ dual(2, tap(Chain2));
var tapEither2 = /* @__PURE__ */ dual(2, tapEither(FromEither2, Chain2));
var fromNullable2 = function(a) {
  return a == null ? none2 : some2(a);
};

// src/std/index.ts
var flow2 = flow;
var pipe2 = pipe;
var A = {
  partitionMap,
  partition,
  findFirst: findFirst2,
  findFirstMap: findFirstMap2,
  map: map2,
  filter
};
var E = {
  isLeft: isLeft2,
  isRight: isRight2,
  left: left2,
  right: right2,
  tryCatchK,
  tryCatch,
  getOrElse,
  map,
  mapLeft,
  bimap,
  flatMap,
  fromNullable
};
var O = {
  map: map3,
  getOrElse: getOrElse2,
  some: some2,
  none: none2,
  fromNullable: fromNullable2
};
var parse2 = tryCatchK(parse, (e) => e);
function parseC(schema, options) {
  return (input) => parse2(schema, input, options);
}
var _EFunSemigroup = class {
  concat(f, g) {
    return (i) => {
      const fRes = f(i);
      if (isRight2(fRes))
        return fRes;
      return g(i);
    };
  }
};
var EFunSemigroup = new _EFunSemigroup();
function trySchemas(schemas, options) {
  const [first, ...rest] = schemas;
  return pipe2(
    rest,
    A.map((schema) => parseC(schema, options)),
    concatAll2(EFunSemigroup)(parseC(first, options))
  );
}

// src/core/settings.ts
var OpenPositionSchema = enumType(["left", "right", "mainView"]);
function isValidOpenPosition(position) {
  return is(OpenPositionSchema, position);
}
var ModalFormSettingsSchema = object({
  editorPosition: optional(OpenPositionSchema, "right"),
  formDefinitions: array(unknown())
});
function getDefaultSettings() {
  return { editorPosition: "right", formDefinitions: [] };
}
var NullSettingsError = class {
  constructor() {
    this._tag = "NullSettingsError";
  }
};
function parseSettings(maybeSettings) {
  return pipe2(
    maybeSettings,
    fromNullable(new NullSettingsError()),
    chainW((s) => parse2(ModalFormSettingsSchema, { ...getDefaultSettings(), ...s }))
  );
}

// src/ModalFormSettingTab.ts
var ModalFormSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  async display() {
    const { containerEl, plugin } = this;
    containerEl.empty();
    const settings2 = await plugin.getSettings();
    new import_obsidian.Setting(containerEl).setName("Editor position").setDesc("Where the form editor will be opened. In mobile it will always be main view.").addDropdown((component) => {
      component.addOptions({
        left: "Left",
        right: "Right",
        mainView: "Main View",
        modal: "Modal"
      }).setValue(settings2.editorPosition).onChange(async (value) => {
        if (isValidOpenPosition(value)) {
          await this.plugin.setEditorPosition(value);
        }
      });
    });
  }
};

// src/core/findInputDefinitionSchema.ts
function stringifyIssues(error) {
  return error.issues.map((issue) => {
    var _a;
    return `${(_a = issue.path) == null ? void 0 : _a.map((i) => i.key)}: ${issue.message} got ${issue.input}`;
  });
}
var InvalidInputTypeError = class {
  constructor(field, inputType) {
    this.field = field;
    this.inputType = inputType;
    this.path = "input.type";
  }
  toString() {
    return `InvalidInputTypeError: ${this.getFieldErrors()[0]}`;
  }
  getFieldErrors() {
    return [`"input.type" is invalid, got: ${JSON.stringify(this.inputType)}`];
  }
};
InvalidInputTypeError._tag = "InvalidInputTypeError";
var InvalidInputError = class {
  constructor(field, error) {
    this.field = field;
    this.error = error;
    var _a, _b;
    this.path = (_b = (_a = error.issues[0].path) == null ? void 0 : _a.map((i) => i.key).join(".")) != null ? _b : "";
  }
  toString() {
    return `InvalidInputError: ${stringifyIssues(this.error).join(", ")}`;
  }
  getFieldErrors() {
    return stringifyIssues(this.error);
  }
};
InvalidInputError._tag = "InvalidInputError";
var _InvalidFieldError = class {
  constructor(field, error) {
    this.field = field;
    this.error = error;
    var _a, _b;
    this.path = (_b = (_a = error.issues[0].path) == null ? void 0 : _a.map((i) => i.key).join(".")) != null ? _b : "";
  }
  toString() {
    return `InvalidFieldError: ${stringifyIssues(this.error).join(", ")}`;
  }
  getFieldErrors() {
    return stringifyIssues(this.error);
  }
  static of(field) {
    return (error) => new _InvalidFieldError(field, error);
  }
};
var InvalidFieldError = _InvalidFieldError;
InvalidFieldError._tag = "InvalidFieldError";
function isValidInputType(input) {
  return "string" === typeof input && input in InputTypeToParserMap;
}
function findInputDefinitionSchema(fieldDefinition) {
  return pipe2(
    parse2(FieldMinimalSchema, fieldDefinition),
    mapLeft(InvalidFieldError.of(fieldDefinition)),
    chainW((field) => {
      const type = field.input.type;
      if (isValidInputType(type))
        return right2([field, InputTypeToParserMap[type]]);
      else
        return left2(new InvalidInputTypeError(field, type));
    })
  );
}
function findFieldErrors(fields) {
  return pipe2(
    fields,
    A.map((fieldUnparsed) => {
      return pipe2(
        findInputDefinitionSchema(fieldUnparsed),
        chainW(
          ([field, parser]) => pipe2(
            parser(field.input),
            bimap(
              (error) => new InvalidInputError(field, error),
              () => field
            )
          )
        )
      );
    })
    // A.partition(E.isLeft),
    // Separated.right,
  );
}

// src/core/formDefinitionSchema.ts
function nonEmptyString(name) {
  return string(`${name} should be a string`, [toTrimmed(), minLength(1, `${name} should not be empty`)]);
}
var InputBasicTypeSchema = enumType(["text", "number", "date", "time", "datetime", "textarea", "toggle", "email", "tel"]);
var SelectFromNotesSchema = object({ type: literal("select"), source: literal("notes"), folder: nonEmptyString("folder name") });
var InputSliderSchema = object({ type: literal("slider"), min: number(), max: number() });
var InputNoteFromFolderSchema = object({ type: literal("note"), folder: nonEmptyString("folder name") });
var InputDataviewSourceSchema = object({ type: literal("dataview"), query: nonEmptyString("dataview query") });
var InputBasicSchema = object({ type: InputBasicTypeSchema });
var InputSelectFixedSchema = object({
  type: literal("select"),
  source: literal("fixed"),
  options: array(object({
    value: string([toTrimmed()]),
    label: string()
  }))
});
var MultiSelectNotesSchema = object({
  type: literal("multiselect"),
  source: literal("notes"),
  folder: nonEmptyString("multi select source folder")
});
var MultiSelectFixedSchema = object({ type: literal("multiselect"), source: literal("fixed"), multi_select_options: array(string()) });
var MultiSelectQuerySchema = object({
  type: literal("multiselect"),
  source: literal("dataview"),
  query: nonEmptyString("dataview query")
});
var MultiselectSchema = union([MultiSelectNotesSchema, MultiSelectFixedSchema, MultiSelectQuerySchema]);
var InputTypeSchema = union([
  InputBasicSchema,
  InputNoteFromFolderSchema,
  InputSliderSchema,
  SelectFromNotesSchema,
  InputDataviewSourceSchema,
  InputSelectFixedSchema,
  MultiselectSchema
]);
var InputTypeToParserMap = {
  number: parseC(InputBasicSchema),
  text: parseC(InputBasicSchema),
  email: parseC(InputBasicSchema),
  tel: parseC(InputBasicSchema),
  date: parseC(InputBasicSchema),
  time: parseC(InputBasicSchema),
  datetime: parseC(InputBasicSchema),
  textarea: parseC(InputBasicSchema),
  toggle: parseC(InputBasicSchema),
  note: parseC(InputNoteFromFolderSchema),
  slider: parseC(InputSliderSchema),
  select: trySchemas([SelectFromNotesSchema, InputSelectFixedSchema]),
  dataview: parseC(InputDataviewSourceSchema),
  multiselect: parseC(MultiselectSchema)
};
var FieldDefinitionSchema = object({
  name: nonEmptyString("field name"),
  label: optional(string()),
  description: string(),
  input: InputTypeSchema
});
var FieldMinimalSchema = passthrough(merge([
  FieldDefinitionSchema,
  object({ input: passthrough(object({ type: string() })) })
]));
var FieldListSchema = array(FieldDefinitionSchema);
var FormDefinitionBasicSchema = object({
  title: nonEmptyString("form title"),
  name: nonEmptyString("form name"),
  customClassname: optional(string()),
  fields: array(unknown())
});
var FormDefinitionV1Schema = merge([FormDefinitionBasicSchema, object({
  version: literal("1"),
  fields: FieldListSchema
})]);
var FormDefinitionLatestSchema = FormDefinitionV1Schema;
var MigrationError = class {
  constructor(form, error) {
    this.form = form;
    this.error = error;
    this.name = form.name;
  }
  toString() {
    return `MigrationError: 
            ${this.error.message}
            ${this.error.issues.map((issue) => issue.message).join(", ")}`;
  }
  // This allows to store the error in the settings, along with the rest of the forms and 
  // have save all the data in one go transparently.
  // This is required so we don't lose the form, even if it is invalid
  toJSON() {
    return this.form;
  }
  get fieldErrors() {
    return findFieldErrors(this.form.fields);
  }
};
MigrationError._tag = "MigrationError";
var InvalidData = class {
  constructor(data, error) {
    this.data = data;
    this.error = error;
  }
  toString() {
    return `InvalidData: ${this.error.issues.map((issue) => issue.message).join(", ")}`;
  }
};
InvalidData._tag = "InvalidData";
function fromV0toV1(data) {
  return pipe2(
    parse2(FormDefinitionV1Schema, { ...data, version: "1" }),
    getOrElseW((error) => new MigrationError(data, error))
  );
}
function migrateToLatest(data) {
  return pipe2(
    // first try a quick one with the latest schema
    parse2(FormDefinitionLatestSchema, data, { abortEarly: true }),
    orElse(() => pipe2(
      parse2(FormDefinitionBasicSchema, data),
      mapLeft((error) => new InvalidData(data, error)),
      map(fromV0toV1)
    ))
  );
}
function formNeedsMigration(data) {
  return !is(FormDefinitionLatestSchema, data);
}

// src/utils/ModalFormError.ts
var ModalFormError = class extends Error {
  constructor(msg, console_msg) {
    super(msg);
    this.console_msg = console_msg;
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }
};

// src/FormModal.ts
var import_obsidian8 = require("obsidian");

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return (
    /** @type {T & S} */
    tar
  );
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    for (const callback of callbacks) {
      callback(void 0);
    }
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    var _a;
    return (_a = this._observer) != null ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) == null ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
  return function(event) {
    event.preventDefault();
    return fn.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function to_number(value) {
  return value === "" ? null : +value;
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = /** @type {string} */
  data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function select_option(select, value, mounting) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function select_value(select) {
  const selected_option = select.querySelector(":checked");
  return selected_option && selected_option.__value;
}
function toggle_class(element2, name, toggle) {
  element2.classList.toggle(name, !!toggle);
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function bind2(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance10, create_fragment10, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance10 ? instance10(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment10 ? create_fragment10($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot2 = function(name) {
          return () => {
            let node;
            const obj = {
              c: function create() {
                node = element("slot");
                if (name !== "default") {
                  attr(node, "name", name);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            $$slots[name] = [create_slot2(name)];
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      var _a;
      if (this.$$r)
        return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      (_a = this.$$c) == null ? void 0 : _a.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  var _a;
  const type = (_a = props_definition[prop]) == null ? void 0 : _a.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// src/utils/array.ts
function remove_inplace(arr, value) {
  const index = arr.indexOf(value);
  if (index > -1) {
    arr.splice(index, 1);
  }
}

// src/suggesters/MultiSuggest.ts
var import_obsidian2 = require("obsidian");
var MultiSuggest = class extends import_obsidian2.AbstractInputSuggest {
  constructor(inputEl, content, onSelectCb, app2) {
    super(app2, inputEl);
    this.inputEl = inputEl;
    this.onSelectCb = onSelectCb;
    this.content = content;
  }
  getSuggestions(inputStr) {
    const lowerCaseInputStr = inputStr.toLocaleLowerCase();
    return [...this.content].filter(
      (content) => content.toLocaleLowerCase().contains(lowerCaseInputStr)
    );
  }
  renderSuggestion(content, el) {
    el.setText(content);
  }
  selectSuggestion(content, evt) {
    this.onSelectCb(content);
    this.inputEl.value = "";
    this.inputEl.blur();
    this.close();
  }
};

// src/views/components/MultiSelect.svelte
function add_css(target) {
  append_styles(target, "svelte-ikykud", ".multi-select-root.svelte-ikykud.svelte-ikykud{display:flex;flex-direction:column;gap:0.5rem;flex:1;--button-size:1.5rem}.badge.svelte-ikykud.svelte-ikykud{--icon-size:var(--icon-xs);--icon-stroke:var(--icon-xs-stroke-width);display:flex;align-items:center;background-color:var(--pill-background);border:var(--pill-border-width) solid var(--pill-border-color);border-radius:var(--pill-radius);color:var(--pill-color);cursor:var(--cursor);font-weight:var(--pill-weight);padding:var(--pill-padding-y);line-height:1;max-width:100%;gap:var(--size-4-2);justify-content:center;align-items:center}.hidden.svelte-ikykud.svelte-ikykud{visibility:hidden}.hidden.svelte-ikykud span.svelte-ikykud{height:var(--button-size)}.badge.svelte-ikykud span.svelte-ikykud{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;min-width:1rem}.badges.svelte-ikykud.svelte-ikykud{display:flex;flex-wrap:wrap;gap:8px;min-height:2rem;padding:0.5rem 0 0 0}button.svelte-ikykud.svelte-ikykud{background:none;border:none;color:inherit;font:inherit;line-height:inherit;padding:0;-webkit-appearance:none;-moz-appearance:none;-o-appearance:none;appearance:none;box-shadow:none;border:none;cursor:pointer;height:var(--button-size);width:var(--button-size)}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  return child_ctx;
}
function create_else_block(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<span class="svelte-ikykud">Nothing selected</span> `;
      attr(div, "class", "badge hidden svelte-ikykud");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_each_block(ctx) {
  let div;
  let span;
  let t0_value = (
    /*value*/
    ctx[8] + ""
  );
  let t0;
  let t1;
  let button;
  let t2;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[6](
        /*value*/
        ctx[8]
      )
    );
  }
  return {
    c() {
      div = element("div");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      button = element("button");
      button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-x"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;
      t2 = space();
      attr(span, "class", "svelte-ikykud");
      attr(button, "class", "svelte-ikykud");
      attr(div, "class", "badge svelte-ikykud");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(span, t0);
      append(div, t1);
      append(div, button);
      append(div, t2);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*selectedVales*/
      1 && t0_value !== (t0_value = /*value*/
      ctx[8] + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment(ctx) {
  let div1;
  let input;
  let createInput_action;
  let t;
  let div0;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*selectedVales*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block(ctx);
  }
  return {
    c() {
      div1 = element("div");
      input = element("input");
      t = space();
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      if (each_1_else) {
        each_1_else.c();
      }
      attr(input, "type", "text");
      attr(input, "class", "form-control");
      attr(input, "placeholder", "Select");
      attr(div0, "class", "badges svelte-ikykud");
      attr(div1, "class", "multi-select-root svelte-ikykud");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, input);
      append(div1, t);
      append(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      if (each_1_else) {
        each_1_else.m(div0, null);
      }
      if (!mounted) {
        dispose = action_destroyer(createInput_action = /*createInput*/
        ctx[1].call(null, input));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*reomoveValue, selectedVales*/
      5) {
        each_value = ensure_array_like(
          /*selectedVales*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div0, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx2, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block(ctx2);
          each_1_else.c();
          each_1_else.m(div0, null);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_each(each_blocks, detaching);
      if (each_1_else)
        each_1_else.d();
      mounted = false;
      dispose();
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { selectedVales = [] } = $$props;
  let { availableOptions = [] } = $$props;
  let { setting } = $$props;
  let { app: app2 } = $$props;
  setting.settingEl.setCssStyles({ alignItems: "baseline" });
  let remainingOptions = new Set(availableOptions);
  function createInput(element2) {
    new MultiSuggest(
      element2,
      remainingOptions,
      (selected) => {
        selectedVales.push(selected);
        remainingOptions.delete(selected);
        $$invalidate(0, selectedVales);
      },
      app2
    );
  }
  function reomoveValue(value) {
    remove_inplace(selectedVales, value);
    $$invalidate(0, selectedVales);
    remainingOptions.add(value);
  }
  const click_handler = (value) => reomoveValue(value);
  $$self.$$set = ($$props2) => {
    if ("selectedVales" in $$props2)
      $$invalidate(0, selectedVales = $$props2.selectedVales);
    if ("availableOptions" in $$props2)
      $$invalidate(3, availableOptions = $$props2.availableOptions);
    if ("setting" in $$props2)
      $$invalidate(4, setting = $$props2.setting);
    if ("app" in $$props2)
      $$invalidate(5, app2 = $$props2.app);
  };
  return [
    selectedVales,
    createInput,
    reomoveValue,
    availableOptions,
    setting,
    app2,
    click_handler
  ];
}
var MultiSelect = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        selectedVales: 0,
        availableOptions: 3,
        setting: 4,
        app: 5
      },
      add_css
    );
  }
};
var MultiSelect_default = MultiSelect;

// node_modules/fp-ts/es6/string.js
var Eq = {
  equals: function(first, second) {
    return first === second;
  }
};
var Semigroup2 = {
  concat: function(first, second) {
    return first + second;
  }
};
var empty2 = "";
var Monoid = {
  concat: Semigroup2.concat,
  empty: empty2
};
var Ord = {
  equals: Eq.equals,
  compare: function(first, second) {
    return first < second ? -1 : first > second ? 1 : 0;
  }
};
var trim = function(s) {
  return s.trim();
};
var split = function(separator) {
  return function(s) {
    var out = s.split(separator);
    return isNonEmpty2(out) ? out : [s];
  };
};

// node_modules/fp-ts/es6/ReadonlyRecord.js
function filterWithIndex(predicateWithIndex) {
  return function(fa) {
    var out = {};
    var changed = false;
    for (var key in fa) {
      if (has.call(fa, key)) {
        var a = fa[key];
        if (predicateWithIndex(key, a)) {
          out[key] = a;
        } else {
          changed = true;
        }
      }
    }
    return changed ? out : fa;
  };
}

// node_modules/fp-ts/es6/Record.js
function filterWithIndex2(predicateWithIndex) {
  return filterWithIndex(predicateWithIndex);
}

// src/core/objectSelect.ts
var KeysSchema = array(coerce(string(), String));
var PickOmitSchema = object({
  pick: optional(KeysSchema),
  omit: optional(KeysSchema)
});
function picKeys(obj) {
  return (keys) => pipe2(
    obj,
    filterWithIndex2((k) => keys.includes(k))
  );
}
function omitKeys(obj) {
  return (keys) => pipe2(
    obj,
    filterWithIndex2((k) => !keys.includes(k))
  );
}
function objectSelect(obj, opts) {
  return pipe2(
    parse2(PickOmitSchema, opts, { abortEarly: true }),
    E.map(
      (opts2) => {
        const picked = pipe2(
          fromNullable2(opts2.pick),
          flatMap2(fromArray),
          map3(picKeys(obj)),
          getOrElse2(() => obj)
        );
        return pipe2(
          fromNullable2(opts2.omit),
          flatMap2(fromArray),
          map3(omitKeys(picked)),
          getOrElse2(() => picked)
        );
      }
    ),
    E.getOrElse(() => obj)
  );
}

// src/core/FormResult.ts
var import_obsidian4 = require("obsidian");

// src/utils/Log.ts
var import_obsidian3 = require("obsidian");
function log_notice(title, msg) {
  const notice = new import_obsidian3.Notice("", 15e3);
  const el = notice.noticeEl;
  el.empty();
  const head3 = el.createEl("h6", { text: title });
  const body = el.createEl("div", { text: msg });
  el.append(head3, body);
}
function log_error(e) {
  if (e instanceof ModalFormError && e.console_msg) {
    log_notice("Modal from error: ", e.message + "\n" + e.console_msg);
    console.error(`Modal form Error:`, e.message, "\n", e.console_msg);
  } else {
    log_notice("Modal from error", e.message);
  }
}

// src/core/FormResult.ts
function isPrimitive(value) {
  return typeof value === "string" || typeof value === "boolean" || typeof value === "number";
}
function isPrimitiveArray(value) {
  return Array.isArray(value) && value.every(isPrimitive);
}
function formDataFromFormOptions(values) {
  const result = {};
  const invalidKeys = [];
  for (const [key, value] of Object.entries(values)) {
    if (Array.isArray(value) && isPrimitiveArray(value)) {
      result[key] = value;
    } else if (isPrimitive(value)) {
      result[key] = value;
    } else {
      invalidKeys.push(key);
    }
  }
  if (invalidKeys.length > 0) {
    log_error(new ModalFormError(`Invalid keys in form options: ${invalidKeys.join(", ")}`));
  }
  return result;
}
var FormResult = class {
  constructor(data, status) {
    this.data = data;
    this.status = status;
  }
  /**
   * Transform  the current data into a frontmatter string, which is expected
   * to be enclosed in `---` when used in a markdown file.
   * This method does not add the enclosing `---` to the string, 
   * so you can put it anywhere inside the frontmatter.
   * @param {Object} [options] an options object describing what options to pick or omit
   * @param {string[]} [options.pick] an array of key names to pick from the data
   * @param {string[]} [options.omit] an array of key names to omit from the data
   * @returns the data formatted as a frontmatter string
   */
  asFrontmatterString(options) {
    const data = objectSelect(this.data, options);
    return (0, import_obsidian4.stringifyYaml)(data);
  }
  /**
   * Return the current data as a block of dataview properties
   * @param {Object} [options] an options object describing what options to pick or omit
   * @param {string[]} [options.pick] an array of key names to pick from the data
   * @param {string[]} [options.omit] an array of key names to omit from the data
   * @returns string
   */
  asDataviewProperties(options) {
    const data = objectSelect(this.data, options);
    return Object.entries(data).map(
      ([key, value]) => `${key}:: ${Array.isArray(value) ? value.map((v) => JSON.stringify(v)) : value}`
    ).join("\n");
  }
  /**
  Returns a copy of the data contained on this result.
  */
  getData() {
    return { ...this.data };
  }
  /**
   * Returns the data formatted as a string matching the provided
   * template.
   */
  asString(template) {
    let result = template;
    for (const [key, value] of Object.entries(this.data)) {
      result = result.replace(new RegExp(`{{${key}}}`, "g"), value + "");
    }
    return result;
  }
};

// src/safety.ts
function exhaustiveGuard(_value) {
  throw new Error(
    `ERROR! Reached forbidden guard function with unexpected value: ${JSON.stringify(
      _value
    )}`
  );
}

// src/utils/files.ts
var import_obsidian5 = require("obsidian");
var FolderDoesNotExistError = class extends Error {
};
FolderDoesNotExistError.tag = "FolderDoesNotExistError";
var NotAFolderError = class extends Error {
  constructor(file) {
    super(`File ${file.path} is not a folder`);
    this.file = file;
  }
};
NotAFolderError.tag = "NotAFolderError";
var _FileDoesNotExistError = class extends Error {
  static of(file) {
    return new _FileDoesNotExistError(`File "${file}" doesn't exist`);
  }
};
var FileDoesNotExistError = _FileDoesNotExistError;
FileDoesNotExistError.tag = "FileDoesNotExistError";
var NotAFileError = class extends Error {
  constructor(file) {
    super(`File ${file.path} is not a file`);
    this.file = file;
  }
};
NotAFileError.tag = "NotAFileError";
function resolve_tfolder(folder_str, app2) {
  return pipe2(
    (0, import_obsidian5.normalizePath)(folder_str),
    (path) => app2.vault.getAbstractFileByPath(path),
    E.fromNullable(new FolderDoesNotExistError(`Folder "${folder_str}" doesn't exist`)),
    E.flatMap((file) => {
      if (!(file instanceof import_obsidian5.TFolder)) {
        return E.left(new NotAFolderError(file));
      }
      return E.right(file);
    })
  );
}
function get_tfiles_from_folder(folder_str, app2) {
  return pipe2(
    resolve_tfolder(folder_str, app2),
    E.flatMap((folder) => {
      const files = [];
      import_obsidian5.Vault.recurseChildren(folder, (file) => {
        if (file instanceof import_obsidian5.TFile) {
          files.push(file);
        }
      });
      return E.right(files);
    }),
    E.map(
      (files) => {
        return files.sort((a, b) => {
          return a.basename.localeCompare(b.basename);
        });
      }
    )
  );
}

// src/suggesters/suggestFile.ts
var import_obsidian6 = require("obsidian");
var FileSuggest = class extends import_obsidian6.AbstractInputSuggest {
  constructor(app2, inputEl, strategy, folder) {
    super(app2, inputEl);
    this.app = app2;
    this.inputEl = inputEl;
    this.strategy = strategy;
    this.folder = folder;
  }
  getSuggestions(input_str) {
    const all_files = get_tfiles_from_folder(this.folder, this.app);
    if (E.isLeft(all_files)) {
      return [];
    }
    const lower_input_str = input_str.toLowerCase();
    return all_files.right.filter((file) => {
      return file instanceof import_obsidian6.TFile && file.extension === "md" && file.path.toLowerCase().contains(lower_input_str);
    });
  }
  renderSuggestion(file, el) {
    el.setText(this.strategy.renderSuggestion(file));
  }
  selectSuggestion(file) {
    this.inputEl.value = this.strategy.selectSuggestion(file);
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/suggesters/suggestFromDataview.ts
var import_obsidian7 = require("obsidian");

// src/suggesters/SafeDataviewQuery.ts
function sandboxedDvQuery(query) {
  if (!query.startsWith("return")) {
    query = "return " + query;
  }
  const run2 = new Function("dv", "pages", query);
  return flow2(
    E.tryCatchK(run2, () => new ModalFormError("Error evaluating the dataview query")),
    E.flatMap((result) => {
      if (!Array.isArray(result)) {
        return E.left(new ModalFormError("The dataview query did not return an array"));
      }
      return E.right(result);
    })
  );
}
function executeSandboxedDvQuery(query, app2) {
  var _a;
  const dv = (_a = app2.plugins.plugins.dataview) == null ? void 0 : _a.api;
  if (!dv) {
    log_error(new ModalFormError("Dataview plugin is not enabled"));
    return [];
  }
  const pages = dv.pages;
  return pipe2(
    query(dv, pages),
    E.getOrElse((e) => {
      log_error(e);
      return [];
    })
  );
}

// src/suggesters/createRegexFromInput.ts
var splitString = flow2(trim, split(" "));
function createRegexFromInput(input) {
  return pipe2(
    fromNullable2(input),
    map3(splitString),
    map3((parts) => parts.join(".*")),
    map3((s) => new RegExp(s, "i")),
    getOrElse2(() => new RegExp(".*"))
  );
}

// src/suggesters/suggestFromDataview.ts
var DataviewSuggest = class extends import_obsidian7.AbstractInputSuggest {
  constructor(inputEl, dvQuery, app2) {
    super(app2, inputEl);
    this.inputEl = inputEl;
    this.app = app2;
    this.sandboxedQuery = sandboxedDvQuery(dvQuery);
  }
  getSuggestions(inputStr) {
    const result = executeSandboxedDvQuery(this.sandboxedQuery, this.app);
    if (!inputStr) {
      return result;
    }
    const regex = createRegexFromInput(inputStr);
    return result.filter((r) => regex.test(r));
  }
  renderSuggestion(option, el) {
    el.setText(option);
  }
  selectSuggestion(option) {
    this.inputEl.value = option;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/FormModal.ts
var FormModal = class extends import_obsidian8.Modal {
  constructor(app2, modalDefinition, onSubmit, options) {
    super(app2);
    this.modalDefinition = modalDefinition;
    this.onSubmit = onSubmit;
    this.svelteComponents = [];
    this.formResult = {};
    if (options == null ? void 0 : options.values) {
      this.formResult = formDataFromFormOptions(options.values);
    }
  }
  onOpen() {
    const { contentEl } = this;
    if (this.modalDefinition.customClassname)
      contentEl.addClass(this.modalDefinition.customClassname);
    contentEl.createEl("h1", { text: this.modalDefinition.title });
    this.modalDefinition.fields.forEach((definition) => {
      const fieldBase = new import_obsidian8.Setting(contentEl).setName(definition.label || definition.name).setDesc(definition.description);
      const fieldInput = definition.input;
      const type = fieldInput.type;
      const initialValue = this.formResult[definition.name];
      switch (type) {
        case "textarea":
          fieldBase.setClass("modal-form-textarea");
          return fieldBase.addTextArea((textEl) => {
            if (typeof initialValue === "string") {
              textEl.setValue(initialValue);
            }
            textEl.onChange((value) => {
              this.formResult[definition.name] = value;
            });
            textEl.inputEl.rows = 6;
            if (import_obsidian8.Platform.isIosApp)
              textEl.inputEl.style.width = "100%";
            else if (import_obsidian8.Platform.isDesktopApp) {
              textEl.inputEl.rows = 10;
            }
          });
        case "email":
        case "tel":
        case "text":
          return fieldBase.addText(
            (text2) => {
              text2.inputEl.type = type;
              initialValue !== void 0 && text2.setValue(String(initialValue));
              return text2.onChange(async (value) => {
                this.formResult[definition.name] = value;
              });
            }
          );
        case "number":
          return fieldBase.addText((text2) => {
            text2.inputEl.type = "number";
            initialValue !== void 0 && text2.setValue(String(initialValue));
            text2.onChange(async (value) => {
              if (value !== "") {
                this.formResult[definition.name] = Number(value) + "";
              }
            });
          });
        case "date":
          return fieldBase.addText((text2) => {
            text2.inputEl.type = "date";
            initialValue !== void 0 && text2.setValue(String(initialValue));
            text2.onChange(async (value) => {
              this.formResult[definition.name] = value;
            });
          });
        case "time":
          return fieldBase.addText((text2) => {
            text2.inputEl.type = "time";
            initialValue !== void 0 && text2.setValue(String(initialValue));
            text2.onChange(async (value) => {
              this.formResult[definition.name] = value;
            });
          });
        case "datetime":
          return fieldBase.addText((text2) => {
            text2.inputEl.type = "datetime-local";
            initialValue !== void 0 && text2.setValue(String(initialValue));
            text2.onChange(async (value) => {
              this.formResult[definition.name] = value;
            });
          });
        case "toggle":
          return fieldBase.addToggle(
            (toggle) => {
              toggle.setValue(!!initialValue);
              this.formResult[definition.name] = !!initialValue;
              return toggle.onChange(async (value) => {
                this.formResult[definition.name] = value;
              });
            }
          );
        case "note":
          return fieldBase.addText((element2) => {
            new FileSuggest(this.app, element2.inputEl, {
              renderSuggestion(file) {
                return file.basename;
              },
              selectSuggestion(file) {
                return file.basename;
              }
            }, fieldInput.folder);
            element2.onChange(async (value) => {
              this.formResult[definition.name] = value;
            });
          });
        case "slider":
          return fieldBase.addSlider((slider) => {
            slider.setLimits(fieldInput.min, fieldInput.max, 1);
            slider.setDynamicTooltip();
            if (typeof initialValue === "number") {
              slider.setValue(initialValue);
            } else {
              slider.setValue(fieldInput.min);
            }
            slider.onChange(async (value) => {
              this.formResult[definition.name] = value;
            });
          });
        case "multiselect": {
          this.formResult[definition.name] = this.formResult[definition.name] || [];
          const source = fieldInput.source;
          const options = source == "fixed" ? fieldInput.multi_select_options : source == "notes" ? pipe2(
            get_tfiles_from_folder(fieldInput.folder, this.app),
            E.map(A.map((file) => file.basename)),
            E.getOrElse((err) => {
              log_error(err);
              return [];
            })
          ) : executeSandboxedDvQuery(sandboxedDvQuery(fieldInput.query), this.app);
          this.svelteComponents.push(new MultiSelect_default({
            target: fieldBase.controlEl,
            props: {
              selectedVales: this.formResult[definition.name],
              availableOptions: options,
              setting: fieldBase,
              app: this.app
            }
          }));
          return;
        }
        case "dataview": {
          const query = fieldInput.query;
          return fieldBase.addText((element2) => {
            new DataviewSuggest(element2.inputEl, query, this.app);
            element2.onChange(async (value) => {
              this.formResult[definition.name] = value;
            });
          });
        }
        case "select":
          {
            const source = fieldInput.source;
            switch (source) {
              case "fixed":
                return fieldBase.addDropdown((element2) => {
                  fieldInput.options.forEach(
                    (option) => {
                      element2.addOption(option.value, option.label);
                    }
                  );
                  this.formResult[definition.name] = element2.getValue();
                  element2.onChange(async (value) => {
                    this.formResult[definition.name] = value;
                  });
                });
              case "notes":
                return fieldBase.addDropdown((element2) => {
                  const files = get_tfiles_from_folder(fieldInput.folder, this.app);
                  pipe2(
                    files,
                    E.map((files2) => files2.reduce(
                      (acc, option) => {
                        acc[option.basename] = option.basename;
                        return acc;
                      },
                      {}
                    )),
                    E.mapLeft((err) => {
                      log_error(err);
                      return err;
                    }),
                    E.map((options) => {
                      element2.addOptions(options);
                    })
                  );
                  this.formResult[definition.name] = element2.getValue();
                  element2.onChange(async (value) => {
                    this.formResult[definition.name] = value;
                  });
                });
              default:
                exhaustiveGuard(source);
            }
          }
          break;
        default:
          return exhaustiveGuard(type);
      }
    });
    const submit = () => {
      this.onSubmit(new FormResult(this.formResult, "ok"));
      this.close();
    };
    new import_obsidian8.Setting(contentEl).addButton(
      (btn) => btn.setButtonText("Submit").setCta().onClick(submit)
    );
    const submitEnterCallback = (evt) => {
      if ((evt.ctrlKey || evt.metaKey) && evt.key === "Enter") {
        evt.preventDefault();
        submit();
      }
    };
    contentEl.addEventListener("keydown", submitEnterCallback);
  }
  onClose() {
    const { contentEl } = this;
    this.svelteComponents.forEach((component) => component.$destroy());
    contentEl.empty();
    this.formResult = {};
  }
};

// src/API.ts
function isPickOption(opts) {
  return "pick" in opts && Array.isArray(opts.pick);
}
function isOmitOption(opts) {
  return "omit" in opts && Array.isArray(opts.omit);
}
var API = class {
  /**
   * Constructor for the API class
   * @param {App} app - The application instance
   * @param {typeof ModalFormPlugin} plugin - The plugin instance
   */
  constructor(app2, plugin) {
    this.app = app2;
    this.plugin = plugin;
  }
  /**
   * Opens a modal form with the provided form definition
   * @param {FormDefinition} formDefinition - The form definition to use
   * @returns {Promise<FormResult>} - A promise that resolves with the form result
   */
  openModalForm(formDefinition, options) {
    return new Promise((resolve) => {
      new FormModal(
        this.app,
        formDefinition,
        resolve,
        options
      ).open();
    });
  }
  exampleForm() {
    return this.openModalForm(exampleModalDefinition);
  }
  getFormByName(name) {
    var _a;
    const form = (_a = this.plugin.settings) == null ? void 0 : _a.formDefinitions.find((form2) => form2.name === name);
    if (form instanceof MigrationError) {
      log_notice(
        "\u{1F6AB} The form you tried to load has an invalid format",
        `The form "${name}" has an invalid format.We tried to automatically convert it but it failed, please fix it manually in the forms manager.
            `
      );
      return void 0;
    } else {
      return form;
    }
  }
  /**
   * Opens a named form
   * @param {string} name - The name of the form to open
   * @returns {Promise<FormResult>} - A promise that resolves with the form result
   * @throws {ModalFormError} - Throws an error if the form definition is not found
   */
  namedForm(name, options) {
    const formDefinition = this.getFormByName(name);
    if (formDefinition) {
      return this.openModalForm(formDefinition, options);
    } else {
      const error = new ModalFormError(`Form definition ${name} not found`);
      log_error(error);
      return Promise.reject(error);
    }
  }
  limitedForm(name, opts) {
    const formDefinition = this.getFormByName(name);
    let newFormDefinition;
    if (formDefinition) {
      if (isOmitOption(opts)) {
        const omit = opts.omit;
        newFormDefinition = { ...formDefinition, fields: formDefinition.fields.filter((field) => !omit.includes(field.name)) };
      } else if (isPickOption(opts)) {
        newFormDefinition = { ...formDefinition, fields: formDefinition.fields.filter((field) => opts.pick.includes(field.name)) };
      } else {
        throw new ModalFormError("Invalid options provided to limitedForm", `GOT: ${JSON.stringify(opts)}`);
      }
      return this.openModalForm(newFormDefinition);
    } else {
      const error = new ModalFormError(`Form definition ${name} not found`);
      log_error(error);
      return Promise.reject(error);
    }
  }
  /**
   * Opens a form with the provided form reference
   * @param {string | FormDefinition} formReference - The form reference, either a form name of an existing form or an inline form definition
   * @returns {Promise<FormResult>} - A promise that resolves with the form result
   * @throws {ModalFormError} - Throws an error if the form reference is not found
   */
  openForm(formReference, options) {
    if (typeof formReference === "string") {
      return this.namedForm(formReference, options);
    } else {
      return this.openModalForm(formReference, options);
    }
  }
};

// src/views/EditFormView.ts
var import_obsidian13 = require("obsidian");

// src/core/formDefinition.ts
var FieldTypeReadable = {
  text: "Text",
  number: "Number",
  email: "Email",
  tel: "Phone",
  date: "Date",
  time: "Time",
  datetime: "DateTime",
  textarea: "Text area",
  toggle: "Toggle",
  "note": "Note",
  "slider": "Slider",
  "select": "Select",
  "dataview": "Dataview",
  "multiselect": "Multiselect"
};
function validateFields(fields) {
  const result = safeParse(FieldListSchema, fields);
  if (result.success) {
    return [];
  }
  console.error("Fields issues", result.issues);
  return result.issues.map(
    (issue) => {
      var _a, _b, _c, _d;
      return {
        message: issue.message,
        path: (_a = issue.path) == null ? void 0 : _a.map((item) => item.key).join("."),
        index: (_d = (_c = (_b = issue.path) == null ? void 0 : _b[0]) == null ? void 0 : _c.key) != null ? _d : 0
      };
    }
  );
}
function isValidFormDefinition(input) {
  if (!is(FormDefinitionBasicSchema, input)) {
    return false;
  }
  console.log("basic is valid");
  const fieldsAreValid = is(FieldListSchema, input.fields);
  if (!fieldsAreValid) {
    return false;
  }
  console.log("fields are valid");
  return true;
}
function duplicateForm(formName, forms) {
  return pipe2(
    forms,
    A.findFirstMap((f) => {
      if (f instanceof MigrationError) {
        return O.none;
      }
      if (f.name === formName) {
        return O.some(f);
      }
      return O.none;
    }),
    O.map((f) => {
      let newName = f.name + "-copy";
      let i = 1;
      while (forms.some((f2) => f2.name === newName)) {
        newName = f.name + "-copy-" + i;
        i++;
      }
      return { ...f, name: newName };
    }),
    O.map((f) => {
      return [...forms, f];
    }),
    O.getOrElse(() => forms)
  );
}

// src/views/FormBuilder.svelte
var import_obsidian12 = require("obsidian");

// src/views/components/FormRow.svelte
function add_css2(target) {
  append_styles(target, "svelte-1xgum2", ".field-goup.svelte-1xgum2{display:flex;flex-direction:column;gap:0.5rem}.hidden-label.svelte-1xgum2{white-space:nowrap;overflow:hidden;visibility:hidden}");
}
function create_fragment2(ctx) {
  let div;
  let label_1;
  let t0;
  let t1;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      div = element("div");
      label_1 = element("label");
      t0 = text(
        /*label*/
        ctx[0]
      );
      t1 = space();
      if (default_slot)
        default_slot.c();
      attr(
        label_1,
        "for",
        /*id*/
        ctx[1]
      );
      attr(label_1, "class", "svelte-1xgum2");
      toggle_class(
        label_1,
        "hidden-label",
        /*hideLabel*/
        ctx[2]
      );
      attr(div, "class", "field-goup svelte-1xgum2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label_1);
      append(label_1, t0);
      append(div, t1);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*label*/
      1)
        set_data(
          t0,
          /*label*/
          ctx2[0]
        );
      if (!current || dirty & /*id*/
      2) {
        attr(
          label_1,
          "for",
          /*id*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*hideLabel*/
      4) {
        toggle_class(
          label_1,
          "hidden-label",
          /*hideLabel*/
          ctx2[2]
        );
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { label } = $$props;
  let { id } = $$props;
  let { hideLabel = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("label" in $$props2)
      $$invalidate(0, label = $$props2.label);
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
    if ("hideLabel" in $$props2)
      $$invalidate(2, hideLabel = $$props2.hideLabel);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [label, id, hideLabel, $$scope, slots];
}
var FormRow = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, { label: 0, id: 1, hideLabel: 2 }, add_css2);
  }
};
var FormRow_default = FormRow;

// src/views/components/inputBuilderDataview.svelte
function create_default_slot(ctx) {
  let span;
  let t8;
  let textarea;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      span.innerHTML = `This is a <a href="https://blacksmithgu.github.io/obsidian-dataview/api/intro/">Dataview</a>
        query that will be used to populate the input suggestions. You should provide
        a query that returns a list of strings, for example:
        <pre class="language-js"><code>dv.pages(&#39;#tag&#39;).map(p =&gt; p.file.name)</code></pre>
        It is recommended to take advantage of<a href="https://blacksmithgu.github.io/obsidian-dataview/api/data-array">Swizzling</a>
        to write shorter queries:
        <pre class="language-js"><code>dv.pages.tag(&#39;#tag&#39;).file.name</code></pre>`;
      t8 = space();
      textarea = element("textarea");
      attr(span, "class", "modal-form-hint");
      attr(
        textarea,
        "id",
        /*id*/
        ctx[1]
      );
      attr(textarea, "name", "dataview_query");
      attr(textarea, "class", "form-control");
      attr(textarea, "rows", "3");
      attr(textarea, "placeholder", "dv.pages('#tag').map(p => p.file.name)");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      insert(target, t8, anchor);
      insert(target, textarea, anchor);
      set_input_value(
        textarea,
        /*value*/
        ctx[0]
      );
      if (!mounted) {
        dispose = listen(
          textarea,
          "input",
          /*textarea_input_handler*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*id*/
      2) {
        attr(
          textarea,
          "id",
          /*id*/
          ctx2[1]
        );
      }
      if (dirty & /*value*/
      1) {
        set_input_value(
          textarea,
          /*value*/
          ctx2[0]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
        detach(t8);
        detach(textarea);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment3(ctx) {
  let formrow;
  let current;
  formrow = new FormRow_default({
    props: {
      label: "Dataview Query",
      id: (
        /*id*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(formrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(formrow, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const formrow_changes = {};
      if (dirty & /*id*/
      2)
        formrow_changes.id = /*id*/
        ctx2[1];
      if (dirty & /*$$scope, id, value*/
      19) {
        formrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formrow.$set(formrow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(formrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(formrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(formrow, detaching);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let id;
  let { index } = $$props;
  let { value = "" } = $$props;
  function textarea_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$props2) => {
    if ("index" in $$props2)
      $$invalidate(2, index = $$props2.index);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*index*/
    4) {
      $:
        $$invalidate(1, id = `dataview_${index}`);
    }
  };
  return [value, id, index, textarea_input_handler];
}
var InputBuilderDataview = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, { index: 2, value: 0 });
  }
};
var inputBuilderDataview_default = InputBuilderDataview;

// src/views/components/InputBuilderSelect.svelte
var import_obsidian11 = require("obsidian");

// src/views/components/InputFolder.svelte
var import_obsidian10 = require("obsidian");

// src/suggesters/suggestFolder.ts
var import_obsidian9 = require("obsidian");
var FolderSuggest = class extends import_obsidian9.AbstractInputSuggest {
  constructor(inputEl, app2) {
    super(app2, inputEl);
    this.inputEl = inputEl;
    this.app = app2;
  }
  getSuggestions(inputStr) {
    const abstractFiles = this.app.vault.getAllLoadedFiles();
    const lowerCaseInputStr = inputStr.toLowerCase();
    const folders = abstractFiles.reduce((acc, folder) => {
      if (folder instanceof import_obsidian9.TFolder && folder.path.toLowerCase().contains(lowerCaseInputStr)) {
        acc.push(folder);
      }
      return acc;
    }, []);
    return folders;
  }
  renderSuggestion(file, el) {
    el.setText(file.path);
  }
  selectSuggestion(file) {
    this.inputEl.value = file.path;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/views/components/InputFolder.svelte
function create_fragment4(ctx) {
  let div;
  let label;
  let t;
  let searchFolder_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      label = element("label");
      t = text("Source Folder");
      attr(
        label,
        "for",
        /*id*/
        ctx[0]
      );
      attr(div, "class", "modal-form flex column gap1 remove-padding remove-border fix-suggest");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(label, t);
      if (!mounted) {
        dispose = action_destroyer(searchFolder_action = /*searchFolder*/
        ctx[1].call(null, div));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*id*/
      1) {
        attr(
          label,
          "for",
          /*id*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let id;
  let { index } = $$props;
  let { folder = "" } = $$props;
  let { notifyChange } = $$props;
  function searchFolder(element2) {
    new import_obsidian10.Setting(element2).addSearch((search) => {
      search.setPlaceholder("Select a folder");
      search.setValue(folder);
      new FolderSuggest(search.inputEl, app);
      search.onChange((value) => {
        $$invalidate(2, folder = value);
        notifyChange();
      });
    });
  }
  $$self.$$set = ($$props2) => {
    if ("index" in $$props2)
      $$invalidate(3, index = $$props2.index);
    if ("folder" in $$props2)
      $$invalidate(2, folder = $$props2.folder);
    if ("notifyChange" in $$props2)
      $$invalidate(4, notifyChange = $$props2.notifyChange);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*index*/
    8) {
      $:
        $$invalidate(0, id = `input_folder_${index}`);
    }
  };
  return [id, searchFolder, folder, index, notifyChange];
}
var InputFolder = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, { index: 3, folder: 2, notifyChange: 4 });
  }
};
var InputFolder_default = InputFolder;

// src/views/components/InputBuilderSelect.svelte
function add_css3(target) {
  append_styles(target, "svelte-1on8key", "button.svelte-1on8key:disabled{opacity:0.5;cursor:forbidden}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i];
  child_ctx[22] = list;
  child_ctx[23] = i;
  const constants_0 = `${/*options_id*/
  child_ctx[7]}_option_${/*idx*/
  child_ctx[23]}`;
  child_ctx[21] = constants_0;
  return child_ctx;
}
function get_else_ctx(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = `${/*options_id*/
  child_ctx[7]}_option_label_${/*idx*/
  child_ctx[23]}`;
  child_ctx[24] = constants_0;
  return child_ctx;
}
function create_if_block_4(ctx) {
  let option_1;
  return {
    c() {
      option_1 = element("option");
      option_1.textContent = "Dataview";
      option_1.__value = "dataview";
      set_input_value(option_1, option_1.__value);
    },
    m(target, anchor) {
      insert(target, option_1, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(option_1);
      }
    }
  };
}
function create_default_slot_7(ctx) {
  let select;
  let option0;
  let option1;
  let mounted;
  let dispose;
  let if_block = (
    /*is_multi*/
    ctx[6] && create_if_block_4(ctx)
  );
  return {
    c() {
      select = element("select");
      option0 = element("option");
      option0.textContent = "Static";
      option1 = element("option");
      option1.textContent = "Notes";
      if (if_block)
        if_block.c();
      option0.__value = "fixed";
      set_input_value(option0, option0.__value);
      option1.__value = "notes";
      set_input_value(option1, option1.__value);
      attr(
        select,
        "id",
        /*id*/
        ctx[8]
      );
      if (
        /*source*/
        ctx[0] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[10].call(select)
        ));
    },
    m(target, anchor) {
      insert(target, select, anchor);
      append(select, option0);
      append(select, option1);
      if (if_block)
        if_block.m(select, null);
      select_option(
        select,
        /*source*/
        ctx[0],
        true
      );
      if (!mounted) {
        dispose = listen(
          select,
          "change",
          /*select_change_handler*/
          ctx[10]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (
        /*is_multi*/
        ctx2[6]
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block_4(ctx2);
          if_block.c();
          if_block.m(select, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*id*/
      256) {
        attr(
          select,
          "id",
          /*id*/
          ctx2[8]
        );
      }
      if (dirty & /*source*/
      1) {
        select_option(
          select,
          /*source*/
          ctx2[0]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(select);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_3(ctx) {
  let inputbuilderdataview;
  let updating_value;
  let current;
  function inputbuilderdataview_value_binding(value) {
    ctx[19](value);
  }
  let inputbuilderdataview_props = { index: (
    /*index*/
    ctx[4]
  ) };
  if (
    /*query*/
    ctx[1] !== void 0
  ) {
    inputbuilderdataview_props.value = /*query*/
    ctx[1];
  }
  inputbuilderdataview = new inputBuilderDataview_default({ props: inputbuilderdataview_props });
  binding_callbacks.push(() => bind2(inputbuilderdataview, "value", inputbuilderdataview_value_binding));
  return {
    c() {
      create_component(inputbuilderdataview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inputbuilderdataview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inputbuilderdataview_changes = {};
      if (dirty & /*index*/
      16)
        inputbuilderdataview_changes.index = /*index*/
        ctx2[4];
      if (!updating_value && dirty & /*query*/
      2) {
        updating_value = true;
        inputbuilderdataview_changes.value = /*query*/
        ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      inputbuilderdataview.$set(inputbuilderdataview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inputbuilderdataview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputbuilderdataview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inputbuilderdataview, detaching);
    }
  };
}
function create_if_block_2(ctx) {
  let inputfolder;
  let updating_folder;
  let current;
  function inputfolder_folder_binding(value) {
    ctx[18](value);
  }
  let inputfolder_props = {
    index: (
      /*index*/
      ctx[4]
    ),
    notifyChange: (
      /*notifyChange*/
      ctx[5]
    )
  };
  if (
    /*folder*/
    ctx[2] !== void 0
  ) {
    inputfolder_props.folder = /*folder*/
    ctx[2];
  }
  inputfolder = new InputFolder_default({ props: inputfolder_props });
  binding_callbacks.push(() => bind2(inputfolder, "folder", inputfolder_folder_binding));
  return {
    c() {
      create_component(inputfolder.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inputfolder, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inputfolder_changes = {};
      if (dirty & /*index*/
      16)
        inputfolder_changes.index = /*index*/
        ctx2[4];
      if (dirty & /*notifyChange*/
      32)
        inputfolder_changes.notifyChange = /*notifyChange*/
        ctx2[5];
      if (!updating_folder && dirty & /*folder*/
      4) {
        updating_folder = true;
        inputfolder_changes.folder = /*folder*/
        ctx2[2];
        add_flush_callback(() => updating_folder = false);
      }
      inputfolder.$set(inputfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inputfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inputfolder, detaching);
    }
  };
}
function create_if_block(ctx) {
  let formrow;
  let current;
  formrow = new FormRow_default({
    props: {
      label: "Options",
      id: (
        /*options_id*/
        ctx[7]
      ),
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(formrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(formrow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const formrow_changes = {};
      if (dirty & /*options_id*/
      128)
        formrow_changes.id = /*options_id*/
        ctx2[7];
      if (dirty & /*$$scope, options, options_id, notifyChange, is_multi*/
      33554664) {
        formrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formrow.$set(formrow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(formrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(formrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(formrow, detaching);
    }
  };
}
function create_default_slot_6(ctx) {
  let button;
  let button_disabled_value;
  let setIcon_action;
  let mounted;
  let dispose;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[12](
        /*idx*/
        ctx[23]
      )
    );
  }
  return {
    c() {
      button = element("button");
      attr(button, "type", "button");
      button.disabled = button_disabled_value = /*idx*/
      ctx[23] === 0;
      attr(button, "class", "svelte-1on8key");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = [
          action_destroyer(setIcon_action = import_obsidian11.setIcon.call(null, button, "arrow-up")),
          listen(button, "click", click_handler_1)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot_5(ctx) {
  let button;
  let button_disabled_value;
  let setIcon_action;
  let mounted;
  let dispose;
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[13](
        /*idx*/
        ctx[23]
      )
    );
  }
  return {
    c() {
      var _a;
      button = element("button");
      attr(button, "type", "button");
      button.disabled = button_disabled_value = /*idx*/
      ctx[23] === /*options*/
      ((_a = ctx[3]) == null ? void 0 : _a.length) - 1;
      attr(button, "class", "svelte-1on8key");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = [
          action_destroyer(setIcon_action = import_obsidian11.setIcon.call(null, button, "arrow-down")),
          listen(button, "click", click_handler_2)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      var _a;
      ctx = new_ctx;
      if (dirty & /*options*/
      8 && button_disabled_value !== (button_disabled_value = /*idx*/
      ctx[23] === /*options*/
      ((_a = ctx[3]) == null ? void 0 : _a.length) - 1)) {
        button.disabled = button_disabled_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block2(ctx) {
  let formrow0;
  let formrow1;
  let current;
  formrow0 = new FormRow_default({
    props: {
      label: "Label",
      id: (
        /*label_id*/
        ctx[24]
      ),
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    }
  });
  formrow1 = new FormRow_default({
    props: {
      label: "Value",
      id: (
        /*value_id*/
        ctx[21]
      ),
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(formrow0.$$.fragment);
      create_component(formrow1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(formrow0, target, anchor);
      mount_component(formrow1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const formrow0_changes = {};
      if (dirty & /*options_id*/
      128)
        formrow0_changes.id = /*label_id*/
        ctx2[24];
      if (dirty & /*$$scope, options_id, options*/
      33554568) {
        formrow0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formrow0.$set(formrow0_changes);
      const formrow1_changes = {};
      if (dirty & /*options_id*/
      128)
        formrow1_changes.id = /*value_id*/
        ctx2[21];
      if (dirty & /*$$scope, options_id, options*/
      33554568) {
        formrow1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formrow1.$set(formrow1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(formrow0.$$.fragment, local);
      transition_in(formrow1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(formrow0.$$.fragment, local);
      transition_out(formrow1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(formrow0, detaching);
      destroy_component(formrow1, detaching);
    }
  };
}
function create_if_block_1(ctx) {
  let formrow;
  let current;
  formrow = new FormRow_default({
    props: {
      label: "Value",
      id: (
        /*value_id*/
        ctx[21]
      ),
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(formrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(formrow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const formrow_changes = {};
      if (dirty & /*options_id*/
      128)
        formrow_changes.id = /*value_id*/
        ctx2[21];
      if (dirty & /*$$scope, options_id, options*/
      33554568) {
        formrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formrow.$set(formrow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(formrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(formrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(formrow, detaching);
    }
  };
}
function create_default_slot_4(ctx) {
  let input;
  let input_id_value;
  let mounted;
  let dispose;
  function input_input_handler_1() {
    ctx[15].call(
      input,
      /*each_value*/
      ctx[22],
      /*idx*/
      ctx[23]
    );
  }
  return {
    c() {
      input = element("input");
      attr(input, "type", "text");
      attr(input, "placeholder", "Label");
      attr(input, "id", input_id_value = /*label_id*/
      ctx[24]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(
        input,
        /*option*/
        ctx[20].label
      );
      if (!mounted) {
        dispose = listen(input, "input", input_input_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*options_id*/
      128 && input_id_value !== (input_id_value = /*label_id*/
      ctx[24])) {
        attr(input, "id", input_id_value);
      }
      if (dirty & /*options*/
      8 && input.value !== /*option*/
      ctx[20].label) {
        set_input_value(
          input,
          /*option*/
          ctx[20].label
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_3(ctx) {
  let input;
  let input_id_value;
  let mounted;
  let dispose;
  function input_input_handler_2() {
    ctx[16].call(
      input,
      /*each_value*/
      ctx[22],
      /*idx*/
      ctx[23]
    );
  }
  return {
    c() {
      input = element("input");
      attr(input, "type", "text");
      attr(input, "placeholder", "Value");
      attr(input, "id", input_id_value = /*value_id*/
      ctx[21]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(
        input,
        /*option*/
        ctx[20].value
      );
      if (!mounted) {
        dispose = listen(input, "input", input_input_handler_2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*options_id*/
      128 && input_id_value !== (input_id_value = /*value_id*/
      ctx[21])) {
        attr(input, "id", input_id_value);
      }
      if (dirty & /*options*/
      8 && input.value !== /*option*/
      ctx[20].value) {
        set_input_value(
          input,
          /*option*/
          ctx[20].value
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_2(ctx) {
  let input;
  let input_id_value;
  let mounted;
  let dispose;
  function input_input_handler() {
    ctx[14].call(
      input,
      /*each_value*/
      ctx[22],
      /*idx*/
      ctx[23]
    );
  }
  return {
    c() {
      input = element("input");
      attr(input, "type", "text");
      attr(input, "placeholder", "Value");
      attr(input, "id", input_id_value = /*value_id*/
      ctx[21]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(
        input,
        /*option*/
        ctx[20]
      );
      if (!mounted) {
        dispose = listen(input, "input", input_input_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*options_id*/
      128 && input_id_value !== (input_id_value = /*value_id*/
      ctx[21])) {
        attr(input, "id", input_id_value);
      }
      if (dirty & /*options*/
      8 && input.value !== /*option*/
      ctx[20]) {
        set_input_value(
          input,
          /*option*/
          ctx[20]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_1(ctx) {
  let button;
  let button_id_value;
  let setIcon_action;
  let mounted;
  let dispose;
  function click_handler_3() {
    return (
      /*click_handler_3*/
      ctx[17](
        /*idx*/
        ctx[23]
      )
    );
  }
  return {
    c() {
      button = element("button");
      attr(button, "id", button_id_value = "button" + /*value_id*/
      ctx[21]);
      attr(button, "type", "button");
      attr(button, "class", "svelte-1on8key");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = [
          action_destroyer(setIcon_action = import_obsidian11.setIcon.call(null, button, "trash")),
          listen(button, "click", click_handler_3)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*options_id*/
      128 && button_id_value !== (button_id_value = "button" + /*value_id*/
      ctx[21])) {
        attr(button, "id", button_id_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block2(ctx) {
  let div;
  let formrow0;
  let t0;
  let formrow1;
  let t1;
  let current_block_type_index;
  let if_block;
  let t2;
  let formrow2;
  let t3;
  let current;
  formrow0 = new FormRow_default({
    props: {
      label: "Button",
      id: "button-up" + /*value_id*/
      ctx[21],
      hideLabel: true,
      $$slots: { default: [create_default_slot_6] },
      $$scope: { ctx }
    }
  });
  formrow1 = new FormRow_default({
    props: {
      label: "Button",
      id: "button-down" + /*value_id*/
      ctx[21],
      hideLabel: true,
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    }
  });
  const if_block_creators = [create_if_block_1, create_else_block2];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if ("string" == typeof /*option*/
    ctx2[20])
      return 0;
    return 1;
  }
  function select_block_ctx(ctx2, index) {
    if (index === 1)
      return get_else_ctx(ctx2);
    return ctx2;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](select_block_ctx(ctx, current_block_type_index));
  formrow2 = new FormRow_default({
    props: {
      label: "Delete",
      id: "button" + /*value_id*/
      ctx[21],
      hideLabel: true,
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(formrow0.$$.fragment);
      t0 = space();
      create_component(formrow1.$$.fragment);
      t1 = space();
      if_block.c();
      t2 = space();
      create_component(formrow2.$$.fragment);
      t3 = space();
      attr(div, "class", "modal-form flex row gap1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(formrow0, div, null);
      append(div, t0);
      mount_component(formrow1, div, null);
      append(div, t1);
      if_blocks[current_block_type_index].m(div, null);
      append(div, t2);
      mount_component(formrow2, div, null);
      append(div, t3);
      current = true;
    },
    p(ctx2, dirty) {
      const formrow0_changes = {};
      if (dirty & /*options_id*/
      128)
        formrow0_changes.id = "button-up" + /*value_id*/
        ctx2[21];
      if (dirty & /*$$scope*/
      33554432) {
        formrow0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formrow0.$set(formrow0_changes);
      const formrow1_changes = {};
      if (dirty & /*options_id*/
      128)
        formrow1_changes.id = "button-down" + /*value_id*/
        ctx2[21];
      if (dirty & /*$$scope, options*/
      33554440) {
        formrow1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formrow1.$set(formrow1_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(select_block_ctx(ctx2, current_block_type_index), dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](select_block_ctx(ctx2, current_block_type_index));
          if_block.c();
        } else {
          if_block.p(select_block_ctx(ctx2, current_block_type_index), dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, t2);
      }
      const formrow2_changes = {};
      if (dirty & /*options_id*/
      128)
        formrow2_changes.id = "button" + /*value_id*/
        ctx2[21];
      if (dirty & /*$$scope, options_id, options, notifyChange*/
      33554600) {
        formrow2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formrow2.$set(formrow2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(formrow0.$$.fragment, local);
      transition_in(formrow1.$$.fragment, local);
      transition_in(if_block);
      transition_in(formrow2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(formrow0.$$.fragment, local);
      transition_out(formrow1.$$.fragment, local);
      transition_out(if_block);
      transition_out(formrow2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(formrow0);
      destroy_component(formrow1);
      if_blocks[current_block_type_index].d();
      destroy_component(formrow2);
    }
  };
}
function create_default_slot2(ctx) {
  let button;
  let t1;
  let each_1_anchor;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*options*/
    ctx[3] || []
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      button = element("button");
      button.textContent = "Add more options";
      t1 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
      attr(button, "type", "button");
      attr(button, "class", "svelte-1on8key");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      insert(target, t1, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[11]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*options_id, options, notifyChange, moveOption*/
      680) {
        each_value = ensure_array_like(
          /*options*/
          ctx2[3] || []
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
        detach(t1);
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment5(ctx) {
  let formrow;
  let t;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  formrow = new FormRow_default({
    props: {
      label: "Source",
      id: (
        /*id*/
        ctx[8]
      ),
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx }
    }
  });
  const if_block_creators = [create_if_block, create_if_block_2, create_if_block_3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*source*/
      ctx2[0] === "fixed"
    )
      return 0;
    if (
      /*source*/
      ctx2[0] === "notes"
    )
      return 1;
    if (
      /*source*/
      ctx2[0] === "dataview"
    )
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      create_component(formrow.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(formrow, target, anchor);
      insert(target, t, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const formrow_changes = {};
      if (dirty & /*id*/
      256)
        formrow_changes.id = /*id*/
        ctx2[8];
      if (dirty & /*$$scope, id, source, is_multi*/
      33554753) {
        formrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formrow.$set(formrow_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(formrow.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(formrow.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
        detach(if_block_anchor);
      }
      destroy_component(formrow, detaching);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let id;
  let options_id;
  let { index } = $$props;
  let { source = "fixed" } = $$props;
  let { query = "" } = $$props;
  let { folder } = $$props;
  let { options = [] } = $$props;
  let { notifyChange } = $$props;
  let { is_multi } = $$props;
  function moveOption(from, direction) {
    const to = direction === "up" ? from - 1 : from + 1;
    if (to < 0 || to >= options.length)
      return;
    const tmp = options[from];
    const target = options[to];
    if (!target || !tmp)
      return;
    $$invalidate(3, options[from] = target, options);
    $$invalidate(3, options[to] = tmp, options);
    $$invalidate(3, options);
    notifyChange();
  }
  function select_change_handler() {
    source = select_value(this);
    $$invalidate(0, source);
  }
  const click_handler = () => {
    if (is_multi) {
      options == null ? void 0 : options.push("");
    } else {
      options == null ? void 0 : options.push({ value: "", label: "" });
    }
    $$invalidate(3, options);
    notifyChange();
  };
  const click_handler_1 = (idx) => moveOption(idx, "up");
  const click_handler_2 = (idx) => moveOption(idx, "down");
  function input_input_handler(each_value, idx) {
    each_value[idx] = this.value;
    $$invalidate(3, options);
  }
  function input_input_handler_1(each_value, idx) {
    each_value[idx].label = this.value;
    $$invalidate(3, options);
  }
  function input_input_handler_2(each_value, idx) {
    each_value[idx].value = this.value;
    $$invalidate(3, options);
  }
  const click_handler_3 = (idx) => {
    $$invalidate(3, options = options == null ? void 0 : options.filter((_, i) => i !== idx));
    notifyChange();
  };
  function inputfolder_folder_binding(value) {
    folder = value;
    $$invalidate(2, folder);
  }
  function inputbuilderdataview_value_binding(value) {
    query = value;
    $$invalidate(1, query);
  }
  $$self.$$set = ($$props2) => {
    if ("index" in $$props2)
      $$invalidate(4, index = $$props2.index);
    if ("source" in $$props2)
      $$invalidate(0, source = $$props2.source);
    if ("query" in $$props2)
      $$invalidate(1, query = $$props2.query);
    if ("folder" in $$props2)
      $$invalidate(2, folder = $$props2.folder);
    if ("options" in $$props2)
      $$invalidate(3, options = $$props2.options);
    if ("notifyChange" in $$props2)
      $$invalidate(5, notifyChange = $$props2.notifyChange);
    if ("is_multi" in $$props2)
      $$invalidate(6, is_multi = $$props2.is_multi);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*index*/
    16) {
      $:
        $$invalidate(8, id = `builder_select_${index}`);
    }
    if ($$self.$$.dirty & /*index*/
    16) {
      $:
        $$invalidate(7, options_id = `builder_select_options_btn_${index}`);
    }
  };
  return [
    source,
    query,
    folder,
    options,
    index,
    notifyChange,
    is_multi,
    options_id,
    id,
    moveOption,
    select_change_handler,
    click_handler,
    click_handler_1,
    click_handler_2,
    input_input_handler,
    input_input_handler_1,
    input_input_handler_2,
    click_handler_3,
    inputfolder_folder_binding,
    inputbuilderdataview_value_binding
  ];
}
var InputBuilderSelect = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance5,
      create_fragment5,
      safe_not_equal,
      {
        index: 4,
        source: 0,
        query: 1,
        folder: 2,
        options: 3,
        notifyChange: 5,
        is_multi: 6
      },
      add_css3
    );
  }
};
var InputBuilderSelect_default = InputBuilderSelect;

// src/views/FormBuilder.svelte
function add_css4(target) {
  append_styles(target, "svelte-19c10g5", ".wrapper.svelte-19c10g5,form.svelte-19c10g5{max-height:100%;min-height:100%;height:100%;display:flex;flex-direction:column}.header.svelte-19c10g5{box-shadow:var(--shadow-bottom) var(--divider-color);padding:1rem}.fields.svelte-19c10g5{overflow-y:auto;padding:1rem}.flex.svelte-19c10g5{display:flex}.column.svelte-19c10g5{flex-direction:column}.gap1.svelte-19c10g5{gap:0.5rem}.gap2.svelte-19c10g5{gap:1rem}fieldset.svelte-19c10g5{border:none;padding:0}.hint.svelte-19c10g5{color:var(--color-base-70)}.error.svelte-19c10g5{color:var(--text-error);font-weight:bold}button.svelte-19c10g5:disabled{opacity:0.5;cursor:forbidden}@media(min-width: 58rem){.md-row.svelte-19c10g5{flex-direction:row}}");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[37] = list[i];
  child_ctx[40] = list;
  child_ctx[41] = i;
  const constants_0 = `desc_${/*index*/
  child_ctx[41]}`;
  child_ctx[38] = constants_0;
  const constants_1 = `delete_${/*index*/
  child_ctx[41]}`;
  child_ctx[39] = constants_1;
  return child_ctx;
}
function get_if_ctx(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = `min_${/*index*/
  child_ctx[41]}`;
  child_ctx[42] = constants_0;
  const constants_1 = `max_${/*index*/
  child_ctx[41]}`;
  child_ctx[43] = constants_1;
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[44] = list[i];
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[47] = list[i];
  return child_ctx;
}
function create_if_block_6(ctx) {
  let h3;
  let t2;
  let ul;
  let each_value_2 = ensure_array_like(
    /*errors*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  return {
    c() {
      h3 = element("h3");
      h3.innerHTML = `<span class="error svelte-19c10g5">Form is invalid</span>, check the
                    following:`;
      t2 = space();
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      set_style(h3, "margin", "0");
      set_style(ul, "margin", "0");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      insert(target, t2, anchor);
      insert(target, ul, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*activeFieldIndex, errors*/
      24) {
        each_value_2 = ensure_array_like(
          /*errors*/
          ctx2[4]
        );
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
        detach(t2);
        detach(ul);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_7(ctx) {
  let t0;
  let t1_value = (
    /*error*/
    ctx[47].path + ""
  );
  let t1;
  return {
    c() {
      t0 = text("at ");
      t1 = text(t1_value);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*errors*/
      16 && t1_value !== (t1_value = /*error*/
      ctx2[47].path + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
    }
  };
}
function create_each_block_2(ctx) {
  let li;
  let t0_value = (
    /*error*/
    ctx[47].message + ""
  );
  let t0;
  let t1;
  let t2;
  let button;
  let t4;
  let mounted;
  let dispose;
  let if_block = (
    /*error*/
    ctx[47].path && create_if_block_7(ctx)
  );
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[16](
        /*error*/
        ctx[47]
      )
    );
  }
  return {
    c() {
      li = element("li");
      t0 = text(t0_value);
      t1 = space();
      if (if_block)
        if_block.c();
      t2 = space();
      button = element("button");
      button.textContent = "Go to problem";
      t4 = space();
      attr(button, "type", "button");
      attr(button, "class", "svelte-19c10g5");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, t0);
      append(li, t1);
      if (if_block)
        if_block.m(li, null);
      append(li, t2);
      append(li, button);
      append(li, t4);
      if (!mounted) {
        dispose = listen(button, "click", click_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*errors*/
      16 && t0_value !== (t0_value = /*error*/
      ctx[47].message + ""))
        set_data(t0, t0_value);
      if (
        /*error*/
        ctx[47].path
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_7(ctx);
          if_block.c();
          if_block.m(li, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block3(ctx) {
  let t;
  return {
    c() {
      t = text("No fields yet");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block2(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*definition*/
    ctx[0].fields
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*definition, duplicateField, moveField, onChange, activeFieldIndex*/
      203) {
        each_value = ensure_array_like(
          /*definition*/
          ctx2[0].fields
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_1(ctx) {
  let option;
  let t_value = (
    /*type*/
    ctx[44][1] + ""
  );
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = /*type*/
      ctx[44][0];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_if_block_5(ctx) {
  let inputbuilderdataview;
  let updating_value;
  let current;
  function inputbuilderdataview_value_binding(value) {
    ctx[31](
      value,
      /*field*/
      ctx[37]
    );
  }
  let inputbuilderdataview_props = { index: (
    /*index*/
    ctx[41]
  ) };
  if (
    /*field*/
    ctx[37].input.query !== void 0
  ) {
    inputbuilderdataview_props.value = /*field*/
    ctx[37].input.query;
  }
  inputbuilderdataview = new inputBuilderDataview_default({ props: inputbuilderdataview_props });
  binding_callbacks.push(() => bind2(inputbuilderdataview, "value", inputbuilderdataview_value_binding));
  return {
    c() {
      create_component(inputbuilderdataview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inputbuilderdataview, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const inputbuilderdataview_changes = {};
      if (!updating_value && dirty[0] & /*definition*/
      1) {
        updating_value = true;
        inputbuilderdataview_changes.value = /*field*/
        ctx[37].input.query;
        add_flush_callback(() => updating_value = false);
      }
      inputbuilderdataview.$set(inputbuilderdataview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inputbuilderdataview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputbuilderdataview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inputbuilderdataview, detaching);
    }
  };
}
function create_if_block_42(ctx) {
  let inputfolder;
  let updating_folder;
  let current;
  function inputfolder_folder_binding(value) {
    ctx[30](
      value,
      /*field*/
      ctx[37]
    );
  }
  let inputfolder_props = {
    index: (
      /*index*/
      ctx[41]
    ),
    notifyChange: (
      /*onChange*/
      ctx[1]
    )
  };
  if (
    /*field*/
    ctx[37].input.folder !== void 0
  ) {
    inputfolder_props.folder = /*field*/
    ctx[37].input.folder;
  }
  inputfolder = new InputFolder_default({ props: inputfolder_props });
  binding_callbacks.push(() => bind2(inputfolder, "folder", inputfolder_folder_binding));
  return {
    c() {
      create_component(inputfolder.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inputfolder, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const inputfolder_changes = {};
      if (dirty[0] & /*onChange*/
      2)
        inputfolder_changes.notifyChange = /*onChange*/
        ctx[1];
      if (!updating_folder && dirty[0] & /*definition*/
      1) {
        updating_folder = true;
        inputfolder_changes.folder = /*field*/
        ctx[37].input.folder;
        add_flush_callback(() => updating_folder = false);
      }
      inputfolder.$set(inputfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inputfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inputfolder, detaching);
    }
  };
}
function create_if_block_32(ctx) {
  let div0;
  let label0;
  let label0_for_value;
  let t1;
  let input0;
  let input0_id_value;
  let t2;
  let div1;
  let label1;
  let label1_for_value;
  let t4;
  let input1;
  let input1_id_value;
  let mounted;
  let dispose;
  function input0_input_handler_2() {
    ctx[28].call(
      input0,
      /*each_value*/
      ctx[40],
      /*index*/
      ctx[41]
    );
  }
  function input1_input_handler_2() {
    ctx[29].call(
      input1,
      /*each_value*/
      ctx[40],
      /*index*/
      ctx[41]
    );
  }
  return {
    c() {
      div0 = element("div");
      label0 = element("label");
      label0.textContent = "Min";
      t1 = space();
      input0 = element("input");
      t2 = space();
      div1 = element("div");
      label1 = element("label");
      label1.textContent = "Max";
      t4 = space();
      input1 = element("input");
      attr(label0, "for", label0_for_value = /*min_id*/
      ctx[42]);
      attr(input0, "type", "number");
      attr(input0, "placeholder", "0");
      attr(input0, "id", input0_id_value = /*min_id*/
      ctx[42]);
      attr(div0, "class", "flex column gap1 svelte-19c10g5");
      attr(label1, "for", label1_for_value = /*max_id*/
      ctx[43]);
      attr(input1, "type", "number");
      attr(input1, "placeholder", "10");
      attr(input1, "id", input1_id_value = /*max_id*/
      ctx[43]);
      attr(div1, "class", "flex column gap1 svelte-19c10g5");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, label0);
      append(div0, t1);
      append(div0, input0);
      set_input_value(
        input0,
        /*field*/
        ctx[37].input.min
      );
      insert(target, t2, anchor);
      insert(target, div1, anchor);
      append(div1, label1);
      append(div1, t4);
      append(div1, input1);
      set_input_value(
        input1,
        /*field*/
        ctx[37].input.max
      );
      if (!mounted) {
        dispose = [
          listen(input0, "input", input0_input_handler_2),
          listen(input1, "input", input1_input_handler_2)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*definition*/
      1 && to_number(input0.value) !== /*field*/
      ctx[37].input.min) {
        set_input_value(
          input0,
          /*field*/
          ctx[37].input.min
        );
      }
      if (dirty[0] & /*definition*/
      1 && to_number(input1.value) !== /*field*/
      ctx[37].input.max) {
        set_input_value(
          input1,
          /*field*/
          ctx[37].input.max
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t2);
        detach(div1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_22(ctx) {
  let inputbuilderselect;
  let updating_source;
  let updating_options;
  let updating_folder;
  let updating_query;
  let current;
  function inputbuilderselect_source_binding_1(value) {
    ctx[24](
      value,
      /*field*/
      ctx[37]
    );
  }
  function inputbuilderselect_options_binding_1(value) {
    ctx[25](
      value,
      /*field*/
      ctx[37]
    );
  }
  function inputbuilderselect_folder_binding_1(value) {
    ctx[26](
      value,
      /*field*/
      ctx[37]
    );
  }
  function inputbuilderselect_query_binding(value) {
    ctx[27](
      value,
      /*field*/
      ctx[37]
    );
  }
  let inputbuilderselect_props = {
    index: (
      /*index*/
      ctx[41]
    ),
    notifyChange: (
      /*onChange*/
      ctx[1]
    ),
    is_multi: true
  };
  if (
    /*field*/
    ctx[37].input.source !== void 0
  ) {
    inputbuilderselect_props.source = /*field*/
    ctx[37].input.source;
  }
  if (
    /*field*/
    ctx[37].input.multi_select_options !== void 0
  ) {
    inputbuilderselect_props.options = /*field*/
    ctx[37].input.multi_select_options;
  }
  if (
    /*field*/
    ctx[37].input.folder !== void 0
  ) {
    inputbuilderselect_props.folder = /*field*/
    ctx[37].input.folder;
  }
  if (
    /*field*/
    ctx[37].input.query !== void 0
  ) {
    inputbuilderselect_props.query = /*field*/
    ctx[37].input.query;
  }
  inputbuilderselect = new InputBuilderSelect_default({ props: inputbuilderselect_props });
  binding_callbacks.push(() => bind2(inputbuilderselect, "source", inputbuilderselect_source_binding_1));
  binding_callbacks.push(() => bind2(inputbuilderselect, "options", inputbuilderselect_options_binding_1));
  binding_callbacks.push(() => bind2(inputbuilderselect, "folder", inputbuilderselect_folder_binding_1));
  binding_callbacks.push(() => bind2(inputbuilderselect, "query", inputbuilderselect_query_binding));
  return {
    c() {
      create_component(inputbuilderselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inputbuilderselect, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const inputbuilderselect_changes = {};
      if (dirty[0] & /*onChange*/
      2)
        inputbuilderselect_changes.notifyChange = /*onChange*/
        ctx[1];
      if (!updating_source && dirty[0] & /*definition*/
      1) {
        updating_source = true;
        inputbuilderselect_changes.source = /*field*/
        ctx[37].input.source;
        add_flush_callback(() => updating_source = false);
      }
      if (!updating_options && dirty[0] & /*definition*/
      1) {
        updating_options = true;
        inputbuilderselect_changes.options = /*field*/
        ctx[37].input.multi_select_options;
        add_flush_callback(() => updating_options = false);
      }
      if (!updating_folder && dirty[0] & /*definition*/
      1) {
        updating_folder = true;
        inputbuilderselect_changes.folder = /*field*/
        ctx[37].input.folder;
        add_flush_callback(() => updating_folder = false);
      }
      if (!updating_query && dirty[0] & /*definition*/
      1) {
        updating_query = true;
        inputbuilderselect_changes.query = /*field*/
        ctx[37].input.query;
        add_flush_callback(() => updating_query = false);
      }
      inputbuilderselect.$set(inputbuilderselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inputbuilderselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputbuilderselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inputbuilderselect, detaching);
    }
  };
}
function create_if_block_12(ctx) {
  let inputbuilderselect;
  let updating_source;
  let updating_options;
  let updating_folder;
  let current;
  function inputbuilderselect_source_binding(value) {
    ctx[21](
      value,
      /*field*/
      ctx[37]
    );
  }
  function inputbuilderselect_options_binding(value) {
    ctx[22](
      value,
      /*field*/
      ctx[37]
    );
  }
  function inputbuilderselect_folder_binding(value) {
    ctx[23](
      value,
      /*field*/
      ctx[37]
    );
  }
  let inputbuilderselect_props = {
    index: (
      /*index*/
      ctx[41]
    ),
    notifyChange: (
      /*onChange*/
      ctx[1]
    ),
    is_multi: false
  };
  if (
    /*field*/
    ctx[37].input.source !== void 0
  ) {
    inputbuilderselect_props.source = /*field*/
    ctx[37].input.source;
  }
  if (
    /*field*/
    ctx[37].input.options !== void 0
  ) {
    inputbuilderselect_props.options = /*field*/
    ctx[37].input.options;
  }
  if (
    /*field*/
    ctx[37].input.folder !== void 0
  ) {
    inputbuilderselect_props.folder = /*field*/
    ctx[37].input.folder;
  }
  inputbuilderselect = new InputBuilderSelect_default({ props: inputbuilderselect_props });
  binding_callbacks.push(() => bind2(inputbuilderselect, "source", inputbuilderselect_source_binding));
  binding_callbacks.push(() => bind2(inputbuilderselect, "options", inputbuilderselect_options_binding));
  binding_callbacks.push(() => bind2(inputbuilderselect, "folder", inputbuilderselect_folder_binding));
  return {
    c() {
      create_component(inputbuilderselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inputbuilderselect, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const inputbuilderselect_changes = {};
      if (dirty[0] & /*onChange*/
      2)
        inputbuilderselect_changes.notifyChange = /*onChange*/
        ctx[1];
      if (!updating_source && dirty[0] & /*definition*/
      1) {
        updating_source = true;
        inputbuilderselect_changes.source = /*field*/
        ctx[37].input.source;
        add_flush_callback(() => updating_source = false);
      }
      if (!updating_options && dirty[0] & /*definition*/
      1) {
        updating_options = true;
        inputbuilderselect_changes.options = /*field*/
        ctx[37].input.options;
        add_flush_callback(() => updating_options = false);
      }
      if (!updating_folder && dirty[0] & /*definition*/
      1) {
        updating_folder = true;
        inputbuilderselect_changes.folder = /*field*/
        ctx[37].input.folder;
        add_flush_callback(() => updating_folder = false);
      }
      inputbuilderselect.$set(inputbuilderselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inputbuilderselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputbuilderselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inputbuilderselect, detaching);
    }
  };
}
function create_each_block3(ctx) {
  let div3;
  let div0;
  let label0;
  let label0_for_value;
  let t1;
  let input0;
  let input0_id_value;
  let t2;
  let div1;
  let label1;
  let label1_for_value;
  let t4;
  let input1;
  let input1_id_value;
  let t5;
  let div2;
  let label2;
  let label2_for_value;
  let scrollWhenActive_action;
  let t8;
  let div6;
  let div4;
  let label3;
  let label3_for_value;
  let t10;
  let input2;
  let input2_id_value;
  let t11;
  let div5;
  let label4;
  let label4_for_value;
  let t13;
  let select;
  let select_id_value;
  let t14;
  let div7;
  let current_block_type_index;
  let if_block;
  let t15;
  let div8;
  let button0;
  let button0_disabled_value;
  let setIcon_action;
  let t16;
  let button1;
  let button1_disabled_value;
  let setIcon_action_1;
  let t17;
  let button2;
  let t19;
  let button3;
  let button3_id_value;
  let setIcon_action_2;
  let t20;
  let hr;
  let current;
  let mounted;
  let dispose;
  function input0_input_handler_1() {
    ctx[17].call(
      input0,
      /*each_value*/
      ctx[40],
      /*index*/
      ctx[41]
    );
  }
  function input1_input_handler_1() {
    ctx[18].call(
      input1,
      /*each_value*/
      ctx[40],
      /*index*/
      ctx[41]
    );
  }
  function input2_input_handler_1() {
    ctx[19].call(
      input2,
      /*each_value*/
      ctx[40],
      /*index*/
      ctx[41]
    );
  }
  let each_value_1 = ensure_array_like(Object.entries(FieldTypeReadable));
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  function select_change_handler() {
    ctx[20].call(
      select,
      /*each_value*/
      ctx[40],
      /*index*/
      ctx[41]
    );
  }
  const if_block_creators = [
    create_if_block_12,
    create_if_block_22,
    create_if_block_32,
    create_if_block_42,
    create_if_block_5
  ];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*field*/
      ctx2[37].input.type === "select"
    )
      return 0;
    if (
      /*field*/
      ctx2[37].input.type === "multiselect"
    )
      return 1;
    if (
      /*field*/
      ctx2[37].input.type === "slider"
    )
      return 2;
    if (
      /*field*/
      ctx2[37].input.type === "note"
    )
      return 3;
    if (
      /*field*/
      ctx2[37].input.type === "dataview"
    )
      return 4;
    return -1;
  }
  function select_block_ctx(ctx2, index) {
    if (index === 2)
      return get_if_ctx(ctx2);
    return ctx2;
  }
  if (~(current_block_type_index = select_block_type_1(ctx, [-1, -1]))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](select_block_ctx(ctx, current_block_type_index));
  }
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[32](
        /*index*/
        ctx[41]
      )
    );
  }
  function click_handler_3() {
    return (
      /*click_handler_3*/
      ctx[33](
        /*index*/
        ctx[41]
      )
    );
  }
  function click_handler_4() {
    return (
      /*click_handler_4*/
      ctx[34](
        /*index*/
        ctx[41]
      )
    );
  }
  function click_handler_5() {
    return (
      /*click_handler_5*/
      ctx[35](
        /*index*/
        ctx[41]
      )
    );
  }
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      label0 = element("label");
      label0.textContent = "Name";
      t1 = space();
      input0 = element("input");
      t2 = space();
      div1 = element("div");
      label1 = element("label");
      label1.textContent = "Label";
      t4 = space();
      input1 = element("input");
      t5 = space();
      div2 = element("div");
      label2 = element("label");
      label2.textContent = `delete ${/*index*/
      ctx[41]}`;
      t8 = space();
      div6 = element("div");
      div4 = element("div");
      label3 = element("label");
      label3.textContent = "Description";
      t10 = space();
      input2 = element("input");
      t11 = space();
      div5 = element("div");
      label4 = element("label");
      label4.textContent = "Type";
      t13 = space();
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t14 = space();
      div7 = element("div");
      if (if_block)
        if_block.c();
      t15 = space();
      div8 = element("div");
      button0 = element("button");
      t16 = space();
      button1 = element("button");
      t17 = space();
      button2 = element("button");
      button2.textContent = "Duplicate";
      t19 = space();
      button3 = element("button");
      t20 = space();
      hr = element("hr");
      attr(label0, "for", label0_for_value = `name_${/*index*/
      ctx[41]}`);
      attr(input0, "type", "text");
      attr(input0, "placeholder", "Name");
      attr(input0, "id", input0_id_value = `name_${/*index*/
      ctx[41]}`);
      attr(div0, "class", "flex column gap1 svelte-19c10g5");
      attr(label1, "for", label1_for_value = `label_${/*index*/
      ctx[41]}`);
      attr(input1, "type", "text");
      attr(input1, "placeholder", "Label");
      attr(input1, "id", input1_id_value = `label_${/*index*/
      ctx[41]}`);
      attr(div1, "class", "flex column gap1 svelte-19c10g5");
      attr(label2, "for", label2_for_value = /*delete_id*/
      ctx[39]);
      set_style(label2, "visibility", "hidden");
      set_style(label2, "overflow", "hidden");
      set_style(label2, "white-space", "nowrap");
      attr(div2, "class", "flex column gap1 svelte-19c10g5");
      attr(div3, "class", "flex column md-row gap2 svelte-19c10g5");
      attr(label3, "for", label3_for_value = /*desc_id*/
      ctx[38]);
      attr(input2, "type", "text");
      attr(input2, "placeholder", "Description");
      attr(input2, "id", input2_id_value = /*desc_id*/
      ctx[38]);
      attr(div4, "class", "flex column gap1 svelte-19c10g5");
      attr(label4, "for", label4_for_value = `type_${/*index*/
      ctx[41]}`);
      attr(select, "id", select_id_value = `type_${/*index*/
      ctx[41]}`);
      if (
        /*field*/
        ctx[37].input.type === void 0
      )
        add_render_callback(select_change_handler);
      attr(div5, "class", "flex column gap1 svelte-19c10g5");
      attr(div6, "class", "flex column md-row gap2 svelte-19c10g5");
      attr(div7, "class", "flex gap1 svelte-19c10g5");
      attr(button0, "type", "button");
      button0.disabled = button0_disabled_value = /*index*/
      ctx[41] === 0;
      attr(button0, "class", "svelte-19c10g5");
      attr(button1, "type", "button");
      button1.disabled = button1_disabled_value = /*index*/
      ctx[41] === /*definition*/
      ctx[0].fields.length - 1;
      attr(button1, "class", "svelte-19c10g5");
      attr(button2, "type", "button");
      attr(button2, "class", "svelte-19c10g5");
      attr(button3, "type", "button");
      attr(button3, "id", button3_id_value = /*delete_id*/
      ctx[39]);
      attr(button3, "class", "svelte-19c10g5");
      attr(div8, "class", "flex gap1 svelte-19c10g5");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div0, label0);
      append(div0, t1);
      append(div0, input0);
      set_input_value(
        input0,
        /*field*/
        ctx[37].name
      );
      append(div3, t2);
      append(div3, div1);
      append(div1, label1);
      append(div1, t4);
      append(div1, input1);
      set_input_value(
        input1,
        /*field*/
        ctx[37].label
      );
      append(div3, t5);
      append(div3, div2);
      append(div2, label2);
      insert(target, t8, anchor);
      insert(target, div6, anchor);
      append(div6, div4);
      append(div4, label3);
      append(div4, t10);
      append(div4, input2);
      set_input_value(
        input2,
        /*field*/
        ctx[37].description
      );
      append(div6, t11);
      append(div6, div5);
      append(div5, label4);
      append(div5, t13);
      append(div5, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*field*/
        ctx[37].input.type,
        true
      );
      insert(target, t14, anchor);
      insert(target, div7, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div7, null);
      }
      insert(target, t15, anchor);
      insert(target, div8, anchor);
      append(div8, button0);
      append(div8, t16);
      append(div8, button1);
      append(div8, t17);
      append(div8, button2);
      append(div8, t19);
      append(div8, button3);
      insert(target, t20, anchor);
      insert(target, hr, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input0, "input", input0_input_handler_1),
          listen(input1, "input", input1_input_handler_1),
          action_destroyer(scrollWhenActive_action = scrollWhenActive.call(
            null,
            div3,
            /*index*/
            ctx[41] === /*activeFieldIndex*/
            ctx[3]
          )),
          listen(input2, "input", input2_input_handler_1),
          listen(select, "change", select_change_handler),
          action_destroyer(setIcon_action = import_obsidian12.setIcon.call(null, button0, "arrow-up")),
          listen(button0, "click", click_handler_2),
          action_destroyer(setIcon_action_1 = import_obsidian12.setIcon.call(null, button1, "arrow-down")),
          listen(button1, "click", click_handler_3),
          listen(button2, "click", click_handler_4),
          action_destroyer(setIcon_action_2 = import_obsidian12.setIcon.call(null, button3, "trash")),
          listen(button3, "click", click_handler_5)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*definition*/
      1 && input0.value !== /*field*/
      ctx[37].name) {
        set_input_value(
          input0,
          /*field*/
          ctx[37].name
        );
      }
      if (dirty[0] & /*definition*/
      1 && input1.value !== /*field*/
      ctx[37].label) {
        set_input_value(
          input1,
          /*field*/
          ctx[37].label
        );
      }
      if (scrollWhenActive_action && is_function(scrollWhenActive_action.update) && dirty[0] & /*activeFieldIndex*/
      8)
        scrollWhenActive_action.update.call(
          null,
          /*index*/
          ctx[41] === /*activeFieldIndex*/
          ctx[3]
        );
      if (dirty[0] & /*definition*/
      1 && input2.value !== /*field*/
      ctx[37].description) {
        set_input_value(
          input2,
          /*field*/
          ctx[37].description
        );
      }
      if (dirty & /*Object*/
      0) {
        each_value_1 = ensure_array_like(Object.entries(FieldTypeReadable));
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty[0] & /*definition*/
      1) {
        select_option(
          select,
          /*field*/
          ctx[37].input.type
        );
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(select_block_ctx(ctx, current_block_type_index), dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](select_block_ctx(ctx, current_block_type_index));
            if_block.c();
          } else {
            if_block.p(select_block_ctx(ctx, current_block_type_index), dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div7, null);
        } else {
          if_block = null;
        }
      }
      if (!current || dirty[0] & /*definition*/
      1 && button1_disabled_value !== (button1_disabled_value = /*index*/
      ctx[41] === /*definition*/
      ctx[0].fields.length - 1)) {
        button1.disabled = button1_disabled_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
        detach(t8);
        detach(div6);
        detach(t14);
        detach(div7);
        detach(t15);
        detach(div8);
        detach(t20);
        detach(hr);
      }
      destroy_each(each_blocks, detaching);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment6(ctx) {
  let div1;
  let form;
  let fieldset0;
  let label0;
  let t1;
  let span0;
  let t3;
  let input0;
  let t4;
  let label1;
  let t6;
  let span1;
  let t8;
  let input1;
  let t9;
  let label2;
  let span2;
  let input2;
  let t12;
  let div0;
  let button0;
  let t14;
  let button1;
  let t15;
  let button1_disabled_value;
  let t16;
  let button2;
  let t17;
  let button2_disabled_value;
  let t18;
  let button3;
  let t20;
  let t21;
  let fieldset1;
  let h3;
  let t23;
  let current_block_type_index;
  let if_block1;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*errors*/
    ctx[4].length > 0 && create_if_block_6(ctx)
  );
  const if_block_creators = [create_if_block2, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*definition*/
      ctx2[0].fields.length > 0
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div1 = element("div");
      form = element("form");
      fieldset0 = element("fieldset");
      label0 = element("label");
      label0.textContent = "Form unique name";
      t1 = space();
      span0 = element("span");
      span0.textContent = "This name will identify this form uniquely, and will be the\n                value you need to provide when calling the method openForm";
      t3 = space();
      input0 = element("input");
      t4 = space();
      label1 = element("label");
      label1.textContent = "Form title";
      t6 = space();
      span1 = element("span");
      span1.textContent = "This is the title that will be shown in the modal when the form\n                is visible";
      t8 = space();
      input1 = element("input");
      t9 = space();
      label2 = element("label");
      label2.textContent = "Custom class Name";
      span2 = element("span");
      span2.textContent = "In case you want to add a class name to the modal form to\n                customize it";
      input2 = element("input");
      t12 = space();
      div0 = element("div");
      button0 = element("button");
      button0.textContent = "Add more fields";
      t14 = space();
      button1 = element("button");
      t15 = text("Preview");
      t16 = space();
      button2 = element("button");
      t17 = text("Save and close");
      t18 = space();
      button3 = element("button");
      button3.textContent = "Cancel";
      t20 = space();
      if (if_block0)
        if_block0.c();
      t21 = space();
      fieldset1 = element("fieldset");
      h3 = element("h3");
      h3.textContent = "Fields";
      t23 = space();
      if_block1.c();
      attr(label0, "for", "name");
      attr(span0, "class", "hint svelte-19c10g5");
      attr(input0, "type", "text");
      attr(input0, "placeholder", "Name");
      attr(input0, "id", "name");
      attr(label1, "for", "title");
      attr(span1, "class", "hint svelte-19c10g5");
      attr(input1, "type", "text");
      attr(input1, "placeholder", "Title");
      attr(input1, "id", "title");
      attr(label2, "for", "customClassname");
      attr(span2, "class", "hint svelte-19c10g5");
      attr(input2, "type", "text");
      attr(input2, "id", "customClassname");
      attr(button0, "type", "button");
      attr(button0, "class", "svelte-19c10g5");
      attr(button1, "type", "button");
      button1.disabled = button1_disabled_value = !/*isValid*/
      ctx[5];
      attr(button1, "class", "svelte-19c10g5");
      attr(button2, "class", "mod-cta svelte-19c10g5");
      attr(button2, "type", "submit");
      button2.disabled = button2_disabled_value = !/*isValid*/
      ctx[5];
      attr(button3, "type", "button");
      attr(button3, "class", "mod-warning svelte-19c10g5");
      attr(div0, "class", "flex row gap2 svelte-19c10g5");
      attr(fieldset0, "class", "flex column gap2 header svelte-19c10g5");
      attr(fieldset1, "class", "flex column gap2 fields svelte-19c10g5");
      attr(form, "class", "svelte-19c10g5");
      attr(div1, "class", "flex column gap2 wrapper modal-form svelte-19c10g5");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, form);
      append(form, fieldset0);
      append(fieldset0, label0);
      append(fieldset0, t1);
      append(fieldset0, span0);
      append(fieldset0, t3);
      append(fieldset0, input0);
      set_input_value(
        input0,
        /*definition*/
        ctx[0].name
      );
      append(fieldset0, t4);
      append(fieldset0, label1);
      append(fieldset0, t6);
      append(fieldset0, span1);
      append(fieldset0, t8);
      append(fieldset0, input1);
      set_input_value(
        input1,
        /*definition*/
        ctx[0].title
      );
      append(fieldset0, t9);
      append(fieldset0, label2);
      append(fieldset0, span2);
      append(fieldset0, input2);
      set_input_value(
        input2,
        /*definition*/
        ctx[0].customClassname
      );
      append(fieldset0, t12);
      append(fieldset0, div0);
      append(div0, button0);
      append(div0, t14);
      append(div0, button1);
      append(button1, t15);
      append(div0, t16);
      append(div0, button2);
      append(button2, t17);
      append(div0, t18);
      append(div0, button3);
      append(fieldset0, t20);
      if (if_block0)
        if_block0.m(fieldset0, null);
      append(form, t21);
      append(form, fieldset1);
      append(fieldset1, h3);
      append(fieldset1, t23);
      if_blocks[current_block_type_index].m(fieldset1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[12]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[13]
          ),
          listen(
            input2,
            "input",
            /*input2_input_handler*/
            ctx[14]
          ),
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[15]
          ),
          listen(
            button1,
            "click",
            /*handlePreview*/
            ctx[9]
          ),
          listen(button3, "click", function() {
            if (is_function(
              /*onCancel*/
              ctx[2]
            ))
              ctx[2].apply(this, arguments);
          }),
          listen(form, "submit", prevent_default(
            /*handleSubmit*/
            ctx[8]
          ))
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*definition*/
      1 && input0.value !== /*definition*/
      ctx[0].name) {
        set_input_value(
          input0,
          /*definition*/
          ctx[0].name
        );
      }
      if (dirty[0] & /*definition*/
      1 && input1.value !== /*definition*/
      ctx[0].title) {
        set_input_value(
          input1,
          /*definition*/
          ctx[0].title
        );
      }
      if (dirty[0] & /*definition*/
      1 && input2.value !== /*definition*/
      ctx[0].customClassname) {
        set_input_value(
          input2,
          /*definition*/
          ctx[0].customClassname
        );
      }
      if (!current || dirty[0] & /*isValid*/
      32 && button1_disabled_value !== (button1_disabled_value = !/*isValid*/
      ctx[5])) {
        button1.disabled = button1_disabled_value;
      }
      if (!current || dirty[0] & /*isValid*/
      32 && button2_disabled_value !== (button2_disabled_value = !/*isValid*/
      ctx[5])) {
        button2.disabled = button2_disabled_value;
      }
      if (
        /*errors*/
        ctx[4].length > 0
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_6(ctx);
          if_block0.c();
          if_block0.m(fieldset0, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block1.c();
        } else {
          if_block1.p(ctx, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(fieldset1, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function scrollWhenActive(element2, isActive) {
  function update3(isActive2) {
    if (isActive2) {
      setTimeout(
        () => {
          element2.scrollIntoView({ behavior: "smooth", block: "center" });
        },
        100
      );
    }
  }
  update3(isActive);
  return { update: update3 };
}
function instance6($$self, $$props, $$invalidate) {
  let isValid;
  let errors;
  let activeFieldIndex;
  let { definition = {
    title: "",
    name: "",
    version: "1",
    fields: []
  } } = $$props;
  let { onChange } = $$props;
  let { onSubmit } = $$props;
  let { onCancel } = $$props;
  let { onPreview } = $$props;
  function findFreeName(fieldIndex) {
    const field = definition.fields[fieldIndex];
    if (!field) {
      log_error(new ModalFormError("Unexpected error, no field at that index", fieldIndex + " leads to undefined"));
      return Date.now() + "";
    }
    let name = field.name;
    const allNames = definition.fields.map((f) => f.name);
    let i = 1;
    while (allNames.includes(name)) {
      name = `${field.name}_${i}`;
      i++;
    }
    return name;
  }
  function duplicateField(fieldIndex) {
    const field = definition.fields[fieldIndex];
    if (!field) {
      log_error(new ModalFormError("Unexpected error, no field at that index", fieldIndex + " leads to undefined"));
      return;
    }
    const newField = Object.assign(Object.assign({}, field), {
      input: structuredClone(field.input),
      name: findFreeName(fieldIndex)
    });
    definition.fields.splice(fieldIndex + 1, 0, newField);
    $$invalidate(0, definition);
    onChange();
    $$invalidate(3, activeFieldIndex = fieldIndex + 1);
  }
  function moveField(from, direction) {
    const to = direction === "up" ? from - 1 : from + 1;
    if (to < 0 || to >= definition.fields.length)
      return;
    const tmp = definition.fields[from];
    const target = definition.fields[to];
    if (!target || !tmp)
      return;
    $$invalidate(0, definition.fields[from] = target, definition);
    $$invalidate(0, definition.fields[to] = tmp, definition);
    $$invalidate(0, definition);
    onChange();
    $$invalidate(3, activeFieldIndex = to);
  }
  const handleSubmit = () => {
    if (!isValidFormDefinition(definition))
      return;
    onSubmit(definition);
  };
  const handlePreview = () => {
    if (!isValidFormDefinition(definition))
      return;
    onPreview(definition);
  };
  function input0_input_handler() {
    definition.name = this.value;
    $$invalidate(0, definition);
  }
  function input1_input_handler() {
    definition.title = this.value;
    $$invalidate(0, definition);
  }
  function input2_input_handler() {
    definition.customClassname = this.value;
    $$invalidate(0, definition);
  }
  const click_handler = () => {
    $$invalidate(
      0,
      definition.fields = [
        ...definition.fields,
        {
          name: "",
          label: "",
          description: "",
          input: { type: "text" }
        }
      ],
      definition
    );
    $$invalidate(3, activeFieldIndex = definition.fields.length - 1);
  };
  const click_handler_1 = (error) => {
    $$invalidate(3, activeFieldIndex = error.index);
  };
  function input0_input_handler_1(each_value, index) {
    each_value[index].name = this.value;
    $$invalidate(0, definition);
  }
  function input1_input_handler_1(each_value, index) {
    each_value[index].label = this.value;
    $$invalidate(0, definition);
  }
  function input2_input_handler_1(each_value, index) {
    each_value[index].description = this.value;
    $$invalidate(0, definition);
  }
  function select_change_handler(each_value, index) {
    each_value[index].input.type = select_value(this);
    $$invalidate(0, definition);
  }
  function inputbuilderselect_source_binding(value, field) {
    if ($$self.$$.not_equal(field.input.source, value)) {
      field.input.source = value;
      $$invalidate(0, definition);
    }
  }
  function inputbuilderselect_options_binding(value, field) {
    if ($$self.$$.not_equal(field.input.options, value)) {
      field.input.options = value;
      $$invalidate(0, definition);
    }
  }
  function inputbuilderselect_folder_binding(value, field) {
    if ($$self.$$.not_equal(field.input.folder, value)) {
      field.input.folder = value;
      $$invalidate(0, definition);
    }
  }
  function inputbuilderselect_source_binding_1(value, field) {
    if ($$self.$$.not_equal(field.input.source, value)) {
      field.input.source = value;
      $$invalidate(0, definition);
    }
  }
  function inputbuilderselect_options_binding_1(value, field) {
    if ($$self.$$.not_equal(field.input.multi_select_options, value)) {
      field.input.multi_select_options = value;
      $$invalidate(0, definition);
    }
  }
  function inputbuilderselect_folder_binding_1(value, field) {
    if ($$self.$$.not_equal(field.input.folder, value)) {
      field.input.folder = value;
      $$invalidate(0, definition);
    }
  }
  function inputbuilderselect_query_binding(value, field) {
    if ($$self.$$.not_equal(field.input.query, value)) {
      field.input.query = value;
      $$invalidate(0, definition);
    }
  }
  function input0_input_handler_2(each_value, index) {
    each_value[index].input.min = to_number(this.value);
    $$invalidate(0, definition);
  }
  function input1_input_handler_2(each_value, index) {
    each_value[index].input.max = to_number(this.value);
    $$invalidate(0, definition);
  }
  function inputfolder_folder_binding(value, field) {
    if ($$self.$$.not_equal(field.input.folder, value)) {
      field.input.folder = value;
      $$invalidate(0, definition);
    }
  }
  function inputbuilderdataview_value_binding(value, field) {
    if ($$self.$$.not_equal(field.input.query, value)) {
      field.input.query = value;
      $$invalidate(0, definition);
    }
  }
  const click_handler_2 = (index) => moveField(index, "up");
  const click_handler_3 = (index) => moveField(index, "down");
  const click_handler_4 = (index) => duplicateField(index);
  const click_handler_5 = (index) => {
    $$invalidate(0, definition.fields = definition.fields.filter((_, i) => i !== index), definition);
  };
  $$self.$$set = ($$props2) => {
    if ("definition" in $$props2)
      $$invalidate(0, definition = $$props2.definition);
    if ("onChange" in $$props2)
      $$invalidate(1, onChange = $$props2.onChange);
    if ("onSubmit" in $$props2)
      $$invalidate(10, onSubmit = $$props2.onSubmit);
    if ("onCancel" in $$props2)
      $$invalidate(2, onCancel = $$props2.onCancel);
    if ("onPreview" in $$props2)
      $$invalidate(11, onPreview = $$props2.onPreview);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*definition*/
    1) {
      $:
        $$invalidate(5, isValid = isValidFormDefinition(definition));
    }
    if ($$self.$$.dirty[0] & /*definition*/
    1) {
      $:
        $$invalidate(4, errors = validateFields(definition.fields));
    }
  };
  $:
    $$invalidate(3, activeFieldIndex = 0);
  return [
    definition,
    onChange,
    onCancel,
    activeFieldIndex,
    errors,
    isValid,
    duplicateField,
    moveField,
    handleSubmit,
    handlePreview,
    onSubmit,
    onPreview,
    input0_input_handler,
    input1_input_handler,
    input2_input_handler,
    click_handler,
    click_handler_1,
    input0_input_handler_1,
    input1_input_handler_1,
    input2_input_handler_1,
    select_change_handler,
    inputbuilderselect_source_binding,
    inputbuilderselect_options_binding,
    inputbuilderselect_folder_binding,
    inputbuilderselect_source_binding_1,
    inputbuilderselect_options_binding_1,
    inputbuilderselect_folder_binding_1,
    inputbuilderselect_query_binding,
    input0_input_handler_2,
    input1_input_handler_2,
    inputfolder_folder_binding,
    inputbuilderdataview_value_binding,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    click_handler_5
  ];
}
var FormBuilder = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance6,
      create_fragment6,
      safe_not_equal,
      {
        definition: 0,
        onChange: 1,
        onSubmit: 10,
        onCancel: 2,
        onPreview: 11
      },
      add_css4,
      [-1, -1]
    );
  }
};
var FormBuilder_default = FormBuilder;

// node_modules/svelte/src/runtime/store/index.js
var subscriber_queue = [];
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set2(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update3(fn) {
    set2(fn(value));
  }
  function subscribe3(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set2, update3) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set: set2, update: update3, subscribe: subscribe3 };
}
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  if (!stores_array.every(Boolean)) {
    throw new Error("derived() expects stores as input, got a falsy value");
  }
  const auto = fn.length < 2;
  return readable(initial_value, (set2, update3) => {
    let started = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set2, update3);
      if (auto) {
        set2(result);
      } else {
        cleanup = is_function(result) ? result : noop;
      }
    };
    const unsubscribers = stores_array.map(
      (store, i) => subscribe(
        store,
        (value) => {
          values[i] = value;
          pending &= ~(1 << i);
          if (started) {
            sync();
          }
        },
        () => {
          pending |= 1 << i;
        }
      )
    );
    started = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
      started = false;
    };
  });
}

// src/store/store.ts
var settings = writable({ ...getDefaultSettings() });
var formsStore = derived(settings, ($settings) => pipe2($settings.formDefinitions, A.filter((form) => !(form instanceof MigrationError))));
var { subscribe: subscribe2, update: update2, set } = settings;
var invalidFormsStore = derived(settings, ($settings) => {
  return pipe2(
    $settings.formDefinitions,
    A.filter((form) => form instanceof MigrationError)
  );
});
var settingsStore = {
  subscribe: subscribe2,
  set,
  updateForm(name, form) {
    update2((s) => {
      const forms = s.formDefinitions.map((f) => {
        if (f.name === name)
          return form;
        return f;
      });
      return { ...s, formDefinitions: forms };
    });
  },
  addNewForm(form) {
    update2((s) => {
      const forms = [...s.formDefinitions, form];
      return { ...s, formDefinitions: forms };
    });
  },
  removeForm(name) {
    update2((s) => {
      const forms = s.formDefinitions.filter((f) => f.name !== name);
      return { ...s, formDefinitions: forms };
    });
  },
  duplicateForm(formName) {
    update2((s) => {
      return { ...s, formDefinitions: duplicateForm(formName, s.formDefinitions) };
    });
  }
};

// src/views/EditFormView.ts
var EDIT_FORM_VIEW = "modal-form-edit-form-view";
function parseState(maybeState) {
  if (maybeState === null) {
    return false;
  }
  if (typeof maybeState !== "object") {
    return false;
  }
  if ("title" in maybeState && "name" in maybeState && "fields" in maybeState) {
    return true;
  }
  return false;
}
var EditFormView = class extends import_obsidian13.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.leaf = leaf;
    this.plugin = plugin;
    this.formState = { title: "", name: "", version: "1", fields: [] };
    this.icon = "note-glyph";
  }
  getViewType() {
    return EDIT_FORM_VIEW;
  }
  getDisplayText() {
    return "Edit form";
  }
  async onOpen() {
    this.containerEl.empty();
    this.formEditor = new FormBuilder_default({
      target: this.containerEl,
      props: {
        definition: this.formState,
        onChange: () => {
          console.log("Save form state", this.formState);
          this.app.workspace.requestSaveLayout();
        },
        onSubmit: (formDefinition) => {
          console.log("Submitting form", { formDefinition });
          if (this.originalFormName && this.originalFormName !== "") {
            settingsStore.updateForm(this.originalFormName, formDefinition);
          } else {
            settingsStore.addNewForm(formDefinition);
          }
          this.plugin.closeEditForm();
        },
        onCancel: () => {
          this.plugin.closeEditForm();
        },
        onPreview: async (formDefinition) => {
          const result = await this.plugin.api.openForm(formDefinition);
          const result_str = JSON.stringify(result, null, 2);
          log_notice("Form result", result_str);
          console.log(result_str);
        }
      }
    });
  }
  async onClose() {
    console.log("onClose of edit form called");
    this.formEditor.$destroy();
  }
  async setState(state, result) {
    console.log("setState of edit form called", state);
    if (parseState(state)) {
      this.formState = state;
      this.originalFormName = state.name;
      this.formEditor.$set({ definition: this.formState });
    }
    return super.setState(state, result);
  }
  getState() {
    return this.formState;
  }
};

// src/views/components/KeyValue.svelte
function add_css5(target) {
  append_styles(target, "svelte-1i8bb6o", "div.svelte-1i8bb6o{display:flex;flex-direction:row;align-items:flex-start;gap:var(--mf-spacing)}.key.svelte-1i8bb6o{color:var(--text-faint)}");
}
function create_fragment7(ctx) {
  let div;
  let span;
  let t0;
  let t1;
  let t2;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  return {
    c() {
      div = element("div");
      span = element("span");
      t0 = text(
        /*key*/
        ctx[0]
      );
      t1 = text(":");
      t2 = space();
      if (default_slot)
        default_slot.c();
      attr(span, "class", "key svelte-1i8bb6o");
      attr(div, "class", "svelte-1i8bb6o");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(span, t0);
      append(span, t1);
      append(div, t2);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*key*/
      1)
        set_data(
          t0,
          /*key*/
          ctx2[0]
        );
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { key } = $$props;
  $$self.$$set = ($$props2) => {
    if ("key" in $$props2)
      $$invalidate(0, key = $$props2.key);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [key, $$scope, slots];
}
var KeyValue = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance7, create_fragment7, safe_not_equal, { key: 0 }, add_css5);
  }
};
var KeyValue_default = KeyValue;

// src/views/components/Button.svelte
var import_obsidian14 = require("obsidian");
function create_fragment8(ctx) {
  let span;
  return {
    c() {
      span = element("span");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      ctx[6](span);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      ctx[6](null);
    }
  };
}
function instance8($$self, $$props, $$invalidate) {
  let { tooltip = void 0 } = $$props;
  let { icon = void 0 } = $$props;
  let { text: text2 = void 0 } = $$props;
  let { variant = "regular" } = $$props;
  let { onClick } = $$props;
  const variants = {
    regular: "modal-form-regular",
    danger: "modal-form-danger",
    primary: "modal-form-primary"
  };
  let root;
  onMount(() => {
    const btn = new import_obsidian14.ButtonComponent(root);
    if (icon)
      btn.setIcon(icon);
    if (tooltip)
      btn.setTooltip(tooltip);
    if (text2)
      btn.setButtonText(text2);
    btn.onClick(onClick);
    btn.setClass(variants[variant]);
  });
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      root = $$value;
      $$invalidate(0, root);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("tooltip" in $$props2)
      $$invalidate(1, tooltip = $$props2.tooltip);
    if ("icon" in $$props2)
      $$invalidate(2, icon = $$props2.icon);
    if ("text" in $$props2)
      $$invalidate(3, text2 = $$props2.text);
    if ("variant" in $$props2)
      $$invalidate(4, variant = $$props2.variant);
    if ("onClick" in $$props2)
      $$invalidate(5, onClick = $$props2.onClick);
  };
  return [root, tooltip, icon, text2, variant, onClick, span_binding];
}
var Button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance8, create_fragment8, safe_not_equal, {
      tooltip: 1,
      icon: 2,
      text: 3,
      variant: 4,
      onClick: 5
    });
  }
};
var Button_default = Button;

// src/views/ManageForms.svelte
function add_css6(target) {
  append_styles(target, "svelte-89smkx", ".form-row.svelte-89smkx{display:flex;flex-direction:column;gap:8px}.form-row-buttons.svelte-89smkx{display:flex;gap:8px}.form-name.svelte-89smkx{margin-bottom:0}.header.svelte-89smkx{display:flex;flex-direction:column;justify-content:space-between;align-items:flex-start}h5.svelte-89smkx{margin-bottom:0}.flex-row.svelte-89smkx{display:flex;flex-direction:row;gap:8px}pre.svelte-89smkx{white-space:pre-wrap}");
}
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i];
  return child_ctx;
}
function get_each_context_12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i];
  return child_ctx;
}
function get_each_context_22(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  return child_ctx;
}
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i];
  return child_ctx;
}
function get_each_context_4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[28] = list[i];
  return child_ctx;
}
function get_each_context_5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[31] = list[i][0];
  child_ctx[32] = list[i][1];
  return child_ctx;
}
function create_if_block_33(ctx) {
  let h5;
  let t0;
  let t1_value = (
    /*$invalidForms*/
    ctx[3].length + ""
  );
  let t1;
  let t2;
  let t3;
  let p;
  return {
    c() {
      h5 = element("h5");
      t0 = text("There are ");
      t1 = text(t1_value);
      t2 = text(" invalid forms.");
      t3 = space();
      p = element("p");
      p.textContent = "Please take a look at the invalid forms section for details and\n            potential fixes.";
      attr(h5, "class", "modal-form-danger svelte-89smkx");
    },
    m(target, anchor) {
      insert(target, h5, anchor);
      append(h5, t0);
      append(h5, t1);
      append(h5, t2);
      insert(target, t3, anchor);
      insert(target, p, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$invalidForms*/
      8 && t1_value !== (t1_value = /*$invalidForms*/
      ctx2[3].length + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(h5);
        detach(t3);
        detach(p);
      }
    }
  };
}
function create_if_block_23(ctx) {
  let keyvalue;
  let current;
  keyvalue = new KeyValue_default({
    props: {
      key: (
        /*key*/
        ctx[31]
      ),
      $$slots: { default: [create_default_slot_32] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(keyvalue.$$.fragment);
    },
    m(target, anchor) {
      mount_component(keyvalue, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const keyvalue_changes = {};
      if (dirty[0] & /*$forms*/
      16)
        keyvalue_changes.key = /*key*/
        ctx2[31];
      if (dirty[0] & /*$forms*/
      16 | dirty[1] & /*$$scope*/
      16) {
        keyvalue_changes.$$scope = { dirty, ctx: ctx2 };
      }
      keyvalue.$set(keyvalue_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(keyvalue.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(keyvalue.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(keyvalue, detaching);
    }
  };
}
function create_default_slot_32(ctx) {
  let span;
  let t_value = (Array.isArray(
    /*value*/
    ctx[32]
  ) ? (
    /*value*/
    ctx[32].length
  ) : (
    /*value*/
    ctx[32]
  )) + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$forms*/
      16 && t_value !== (t_value = (Array.isArray(
        /*value*/
        ctx2[32]
      ) ? (
        /*value*/
        ctx2[32].length
      ) : (
        /*value*/
        ctx2[32]
      )) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_each_block_5(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*key*/
    ctx[31] !== "name" && create_if_block_23(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*key*/
        ctx2[31] !== "name"
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$forms*/
          16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_23(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_each_block_4(ctx) {
  let span;
  let t0_value = (
    /*field*/
    ctx[28].name + ""
  );
  let t0;
  let t1;
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$forms*/
      16 && t0_value !== (t0_value = /*field*/
      ctx2[28].name + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
        detach(t1);
      }
    }
  };
}
function create_default_slot_22(ctx) {
  let span;
  let each_value_4 = ensure_array_like(
    /*form*/
    ctx[17].fields
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_4.length; i += 1) {
    each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
  }
  return {
    c() {
      span = element("span");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      set_style(span, "display", "flex");
      set_style(span, "flex-direction", "column");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(span, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$forms*/
      16) {
        each_value_4 = ensure_array_like(
          /*form*/
          ctx2[17].fields
        );
        let i;
        for (i = 0; i < each_value_4.length; i += 1) {
          const child_ctx = get_each_context_4(ctx2, each_value_4, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(span, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_4.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_3(ctx) {
  let div2;
  let h4;
  let t0_value = (
    /*form*/
    ctx[17].name + ""
  );
  let t0;
  let t1;
  let div0;
  let t2;
  let keyvalue;
  let t3;
  let div1;
  let button0;
  let t4;
  let button1;
  let t5;
  let button2;
  let t7;
  let button3;
  let current;
  let mounted;
  let dispose;
  let each_value_5 = ensure_array_like(Object.entries(
    /*form*/
    ctx[17]
  ));
  let each_blocks = [];
  for (let i = 0; i < each_value_5.length; i += 1) {
    each_blocks[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  keyvalue = new KeyValue_default({
    props: {
      key: "Field names",
      $$slots: { default: [create_default_slot_22] },
      $$scope: { ctx }
    }
  });
  function func() {
    return (
      /*func*/
      ctx[13](
        /*form*/
        ctx[17]
      )
    );
  }
  button0 = new Button_default({
    props: {
      onClick: func,
      tooltip: `Delete ${/*form*/
      ctx[17].name}`,
      icon: "trash",
      variant: "danger"
    }
  });
  function func_1() {
    return (
      /*func_1*/
      ctx[14](
        /*form*/
        ctx[17]
      )
    );
  }
  button1 = new Button_default({
    props: {
      onClick: func_1,
      text: "Edit",
      variant: "primary",
      icon: "pencil"
    }
  });
  function click_handler() {
    return (
      /*click_handler*/
      ctx[15](
        /*form*/
        ctx[17]
      )
    );
  }
  function func_2() {
    return (
      /*func_2*/
      ctx[16](
        /*form*/
        ctx[17]
      )
    );
  }
  button3 = new Button_default({
    props: {
      tooltip: `Copy ${/*form*/
      ctx[17].name} to clipboard`,
      icon: "clipboard-copy",
      onClick: func_2
    }
  });
  return {
    c() {
      div2 = element("div");
      h4 = element("h4");
      t0 = text(t0_value);
      t1 = space();
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      create_component(keyvalue.$$.fragment);
      t3 = space();
      div1 = element("div");
      create_component(button0.$$.fragment);
      t4 = space();
      create_component(button1.$$.fragment);
      t5 = space();
      button2 = element("button");
      button2.innerHTML = `<span>Duplicate</span>`;
      t7 = space();
      create_component(button3.$$.fragment);
      attr(h4, "class", "form-name svelte-89smkx");
      attr(div1, "class", "form-row-buttons svelte-89smkx");
      attr(div2, "class", "form-row svelte-89smkx");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, h4);
      append(h4, t0);
      append(div2, t1);
      append(div2, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      append(div0, t2);
      mount_component(keyvalue, div0, null);
      append(div2, t3);
      append(div2, div1);
      mount_component(button0, div1, null);
      append(div1, t4);
      mount_component(button1, div1, null);
      append(div1, t5);
      append(div1, button2);
      append(div1, t7);
      mount_component(button3, div1, null);
      current = true;
      if (!mounted) {
        dispose = listen(button2, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty[0] & /*$forms*/
      16) && t0_value !== (t0_value = /*form*/
      ctx[17].name + ""))
        set_data(t0, t0_value);
      if (dirty[0] & /*$forms*/
      16) {
        each_value_5 = ensure_array_like(Object.entries(
          /*form*/
          ctx[17]
        ));
        let i;
        for (i = 0; i < each_value_5.length; i += 1) {
          const child_ctx = get_each_context_5(ctx, each_value_5, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_5(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div0, t2);
          }
        }
        group_outros();
        for (i = each_value_5.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      const keyvalue_changes = {};
      if (dirty[0] & /*$forms*/
      16 | dirty[1] & /*$$scope*/
      16) {
        keyvalue_changes.$$scope = { dirty, ctx };
      }
      keyvalue.$set(keyvalue_changes);
      const button0_changes = {};
      if (dirty[0] & /*$forms*/
      16)
        button0_changes.onClick = func;
      if (dirty[0] & /*$forms*/
      16)
        button0_changes.tooltip = `Delete ${/*form*/
        ctx[17].name}`;
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty[0] & /*$forms*/
      16)
        button1_changes.onClick = func_1;
      button1.$set(button1_changes);
      const button3_changes = {};
      if (dirty[0] & /*$forms*/
      16)
        button3_changes.tooltip = `Copy ${/*form*/
        ctx[17].name} to clipboard`;
      if (dirty[0] & /*$forms*/
      16)
        button3_changes.onClick = func_2;
      button3.$set(button3_changes);
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_5.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(keyvalue.$$.fragment, local);
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(button3.$$.fragment, local);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(keyvalue.$$.fragment, local);
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(button3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_each(each_blocks, detaching);
      destroy_component(keyvalue);
      destroy_component(button0);
      destroy_component(button1);
      destroy_component(button3);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block3(ctx) {
  let h3;
  let t1;
  let div;
  let current;
  let each_value = ensure_array_like(
    /*$invalidForms*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      h3 = element("h3");
      h3.textContent = "Invalid forms";
      t1 = space();
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(h3, "class", "form-name modal-form-danger svelte-89smkx");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      insert(target, t1, anchor);
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$invalidForms*/
      8) {
        each_value = ensure_array_like(
          /*$invalidForms*/
          ctx2[3]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
        detach(t1);
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_else_block4(ctx) {
  let keyvalue;
  let current;
  keyvalue = new KeyValue_default({
    props: {
      key: "field",
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(keyvalue.$$.fragment);
    },
    m(target, anchor) {
      mount_component(keyvalue, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const keyvalue_changes = {};
      if (dirty[0] & /*$invalidForms*/
      8 | dirty[1] & /*$$scope*/
      16) {
        keyvalue_changes.$$scope = { dirty, ctx: ctx2 };
      }
      keyvalue.$set(keyvalue_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(keyvalue.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(keyvalue.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(keyvalue, detaching);
    }
  };
}
function create_if_block_13(ctx) {
  let pre;
  let code;
  let t0;
  let t1_value = JSON.stringify(
    /*error*/
    ctx[20].left.field,
    null,
    1
  ) + "";
  let t1;
  let t2;
  let t3;
  let keyvalue;
  let t4;
  let hr;
  let current;
  keyvalue = new KeyValue_default({
    props: {
      key: (
        /*error*/
        ctx[20].left.path
      ),
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      pre = element("pre");
      code = element("code");
      t0 = text("\n                                    ");
      t1 = text(t1_value);
      t2 = text("\n                                ");
      t3 = space();
      create_component(keyvalue.$$.fragment);
      t4 = space();
      hr = element("hr");
      attr(pre, "class", "svelte-89smkx");
    },
    m(target, anchor) {
      insert(target, pre, anchor);
      append(pre, code);
      append(code, t0);
      append(code, t1);
      append(code, t2);
      insert(target, t3, anchor);
      mount_component(keyvalue, target, anchor);
      insert(target, t4, anchor);
      insert(target, hr, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*$invalidForms*/
      8) && t1_value !== (t1_value = JSON.stringify(
        /*error*/
        ctx2[20].left.field,
        null,
        1
      ) + ""))
        set_data(t1, t1_value);
      const keyvalue_changes = {};
      if (dirty[0] & /*$invalidForms*/
      8)
        keyvalue_changes.key = /*error*/
        ctx2[20].left.path;
      if (dirty[0] & /*$invalidForms*/
      8 | dirty[1] & /*$$scope*/
      16) {
        keyvalue_changes.$$scope = { dirty, ctx: ctx2 };
      }
      keyvalue.$set(keyvalue_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(keyvalue.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(keyvalue.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(pre);
        detach(t3);
        detach(t4);
        detach(hr);
      }
      destroy_component(keyvalue, detaching);
    }
  };
}
function create_default_slot_12(ctx) {
  let span;
  let t0_value = (
    /*error*/
    ctx[20].right.name + ""
  );
  let t0;
  let t1;
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = text(" \u2705");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$invalidForms*/
      8 && t0_value !== (t0_value = /*error*/
      ctx2[20].right.name + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_each_block_22(ctx) {
  let span;
  let t_value = (
    /*fieldError*/
    ctx[23] + ""
  );
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$invalidForms*/
      8 && t_value !== (t_value = /*fieldError*/
      ctx2[23] + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_default_slot3(ctx) {
  let each_1_anchor;
  let each_value_2 = ensure_array_like(
    /*error*/
    ctx[20].left.getFieldErrors()
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_22(get_each_context_22(ctx, each_value_2, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$invalidForms*/
      8) {
        each_value_2 = ensure_array_like(
          /*error*/
          ctx2[20].left.getFieldErrors()
        );
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_22(ctx2, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_22(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_12(ctx) {
  let div;
  let show_if;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_13, create_else_block4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty[0] & /*$invalidForms*/
    8)
      show_if = null;
    if (show_if == null)
      show_if = !!E.isLeft(
        /*error*/
        ctx2[20]
      );
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "flex-row svelte-89smkx");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_blocks[current_block_type_index].d();
    }
  };
}
function create_each_block4(ctx) {
  let div;
  let h4;
  let t0_value = (
    /*form*/
    ctx[17].name + ""
  );
  let t0;
  let t1;
  let t2;
  let current;
  let each_value_1 = ensure_array_like(
    /*form*/
    ctx[17].fieldErrors
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_12(get_each_context_12(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      h4 = element("h4");
      t0 = text(t0_value);
      t1 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      attr(h4, "class", "form-name svelte-89smkx");
      attr(div, "class", "form-row svelte-89smkx");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, h4);
      append(h4, t0);
      append(div, t1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      append(div, t2);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*$invalidForms*/
      8) && t0_value !== (t0_value = /*form*/
      ctx2[17].name + ""))
        set_data(t0, t0_value);
      if (dirty[0] & /*$invalidForms*/
      8) {
        each_value_1 = ensure_array_like(
          /*form*/
          ctx2[17].fieldErrors
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_12(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_12(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, t2);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment9(ctx) {
  let div0;
  let h1;
  let t1;
  let button;
  let t2;
  let t3;
  let div1;
  let t4;
  let current;
  button = new Button_default({
    props: {
      onClick: (
        /*createNewForm*/
        ctx[0]
      ),
      text: "Create new form",
      variant: "primary"
    }
  });
  let if_block0 = (
    /*$invalidForms*/
    ctx[3].length && create_if_block_33(ctx)
  );
  let each_value_3 = ensure_array_like(
    /*$forms*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_3.length; i += 1) {
    each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  let if_block1 = (
    /*$invalidForms*/
    ctx[3].length && create_if_block3(ctx)
  );
  return {
    c() {
      div0 = element("div");
      h1 = element("h1");
      h1.textContent = "Manage forms";
      t1 = space();
      create_component(button.$$.fragment);
      t2 = space();
      if (if_block0)
        if_block0.c();
      t3 = space();
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t4 = space();
      if (if_block1)
        if_block1.c();
      attr(div0, "class", "header svelte-89smkx");
      attr(div1, "id", "form-rows");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, h1);
      append(div0, t1);
      mount_component(button, div0, null);
      append(div0, t2);
      if (if_block0)
        if_block0.m(div0, null);
      insert(target, t3, anchor);
      insert(target, div1, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      append(div1, t4);
      if (if_block1)
        if_block1.m(div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty[0] & /*createNewForm*/
      1)
        button_changes.onClick = /*createNewForm*/
        ctx2[0];
      button.$set(button_changes);
      if (
        /*$invalidForms*/
        ctx2[3].length
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_33(ctx2);
          if_block0.c();
          if_block0.m(div0, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty[0] & /*$forms, handleCopyForm, handleDuplicateForm, handleEditForm, handleDeleteForm*/
      496) {
        each_value_3 = ensure_array_like(
          /*$forms*/
          ctx2[4]
        );
        let i;
        for (i = 0; i < each_value_3.length; i += 1) {
          const child_ctx = get_each_context_3(ctx2, each_value_3, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div1, t4);
          }
        }
        group_outros();
        for (i = each_value_3.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (
        /*$invalidForms*/
        ctx2[3].length
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*$invalidForms*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block3(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      for (let i = 0; i < each_value_3.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t3);
        detach(div1);
      }
      destroy_component(button);
      if (if_block0)
        if_block0.d();
      destroy_each(each_blocks, detaching);
      if (if_block1)
        if_block1.d();
    }
  };
}
function instance9($$self, $$props, $$invalidate) {
  let $invalidForms, $$unsubscribe_invalidForms = noop, $$subscribe_invalidForms = () => ($$unsubscribe_invalidForms(), $$unsubscribe_invalidForms = subscribe(invalidForms, ($$value) => $$invalidate(3, $invalidForms = $$value)), invalidForms);
  let $forms, $$unsubscribe_forms = noop, $$subscribe_forms = () => ($$unsubscribe_forms(), $$unsubscribe_forms = subscribe(forms, ($$value) => $$invalidate(4, $forms = $$value)), forms);
  $$self.$$.on_destroy.push(() => $$unsubscribe_invalidForms());
  $$self.$$.on_destroy.push(() => $$unsubscribe_forms());
  let { createNewForm } = $$props;
  let { deleteForm } = $$props;
  let { duplicateForm: duplicateForm2 } = $$props;
  let { editForm } = $$props;
  let { copyFormToClipboard } = $$props;
  let { forms } = $$props;
  $$subscribe_forms();
  let { invalidForms } = $$props;
  $$subscribe_invalidForms();
  function handleDeleteForm(formName) {
    const confirmed = confirm(`Are you sure you want to delete ${formName}?`);
    if (confirmed) {
      console.log(`Deleting ${formName}`);
      deleteForm(formName);
    }
  }
  function handleEditForm(formName) {
    console.log(`Editing ${formName}`);
    editForm(formName);
  }
  function handleDuplicateForm(form) {
    console.log(`Duplicating ${form.name}`);
    duplicateForm2(form.name);
  }
  function handleCopyForm(form) {
    console.log(`Copying ${form.name}`);
    copyFormToClipboard(form);
  }
  const func = (form) => handleDeleteForm(form.name);
  const func_1 = (form) => handleEditForm(form.name);
  const click_handler = (form) => handleDuplicateForm(form);
  const func_2 = (form) => handleCopyForm(form);
  $$self.$$set = ($$props2) => {
    if ("createNewForm" in $$props2)
      $$invalidate(0, createNewForm = $$props2.createNewForm);
    if ("deleteForm" in $$props2)
      $$invalidate(9, deleteForm = $$props2.deleteForm);
    if ("duplicateForm" in $$props2)
      $$invalidate(10, duplicateForm2 = $$props2.duplicateForm);
    if ("editForm" in $$props2)
      $$invalidate(11, editForm = $$props2.editForm);
    if ("copyFormToClipboard" in $$props2)
      $$invalidate(12, copyFormToClipboard = $$props2.copyFormToClipboard);
    if ("forms" in $$props2)
      $$subscribe_forms($$invalidate(1, forms = $$props2.forms));
    if ("invalidForms" in $$props2)
      $$subscribe_invalidForms($$invalidate(2, invalidForms = $$props2.invalidForms));
  };
  return [
    createNewForm,
    forms,
    invalidForms,
    $invalidForms,
    $forms,
    handleDeleteForm,
    handleEditForm,
    handleDuplicateForm,
    handleCopyForm,
    deleteForm,
    duplicateForm2,
    editForm,
    copyFormToClipboard,
    func,
    func_1,
    click_handler,
    func_2
  ];
}
var ManageForms = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance9,
      create_fragment9,
      safe_not_equal,
      {
        createNewForm: 0,
        deleteForm: 9,
        duplicateForm: 10,
        editForm: 11,
        copyFormToClipboard: 12,
        forms: 1,
        invalidForms: 2
      },
      add_css6,
      [-1, -1]
    );
  }
};
var ManageForms_default = ManageForms;

// src/views/ManageFormsView.ts
var import_obsidian15 = require("obsidian");
var MANAGE_FORMS_VIEW = "modal-form-manage-forms-view";
var ManageFormsView = class extends import_obsidian15.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.leaf = leaf;
    this.plugin = plugin;
    this.icon = "documents";
  }
  getViewType() {
    return MANAGE_FORMS_VIEW;
  }
  getDisplayText() {
    return "Manage forms";
  }
  async onOpen() {
    const container = this.containerEl.children[1] || this.containerEl.createDiv();
    container.empty();
    this.component = new ManageForms_default({
      target: container,
      props: {
        forms: formsStore,
        invalidForms: invalidFormsStore,
        createNewForm: () => {
          this.plugin.createNewForm();
        },
        editForm: (formName) => {
          this.plugin.editForm(formName);
        },
        deleteForm: (formName) => {
          settingsStore.removeForm(formName);
        },
        duplicateForm: (formName) => {
          settingsStore.duplicateForm(formName);
        },
        copyFormToClipboard: async (form) => {
          await navigator.clipboard.writeText(JSON.stringify(form, null, 2));
          new import_obsidian15.Notice("Form has been copied to the clipboard");
        }
      }
    });
  }
  async onClose() {
    this.component.$destroy();
  }
};

// src/main.ts
function notifyParsingErrors(errors) {
  if (errors.length === 0) {
    return;
  }
  log_notice(
    "Some forms could not be parsed",
    `We found some invalid data while parsing the form settings, please take a look at the following errors: 
            ${errors.join("\n")}`
  );
}
function notifyMigrationErrors(errors) {
  if (errors.length === 0) {
    return;
  }
  log_notice(
    "Some forms could not be migrated",
    `We tried to perform an automatic migration, but we failed. Go to the forms manager and fix the following forms:
            ${errors.map((e) => e.name).join("\n")}`
  );
}
var ModalFormPlugin = class extends import_obsidian16.Plugin {
  constructor() {
    super(...arguments);
    this.unsubscribeSettingsStore = () => {
    };
  }
  manageForms() {
    return this.activateView(MANAGE_FORMS_VIEW);
  }
  createNewForm() {
    return this.activateView(EDIT_FORM_VIEW);
  }
  /**
   * Opens the form in the editor.
   * @returns 
   */
  async editForm(formName) {
    const savedSettings = await this.getSettings();
    const formDefinition = savedSettings.formDefinitions.find((form) => form.name === formName);
    if (!formDefinition) {
      throw new ModalFormError(`Form ${formName} not found`);
    }
    if (formDefinition instanceof MigrationError) {
      notifyMigrationErrors([formDefinition]);
      return;
    }
    await this.activateView(EDIT_FORM_VIEW, formDefinition);
  }
  closeEditForm() {
    this.app.workspace.detachLeavesOfType(EDIT_FORM_VIEW);
  }
  onunload() {
    this.unsubscribeSettingsStore();
  }
  async activateView(viewType, state) {
    var _a, _b, _c, _d;
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(viewType)[0];
    if (leaf) {
      console.info("found leaf, no reason to create a new one");
    } else if (import_obsidian16.Platform.isMobile || ((_a = this.settings) == null ? void 0 : _a.editorPosition) === "mainView") {
      leaf = this.app.workspace.getLeaf("tab");
    } else if (((_b = this.settings) == null ? void 0 : _b.editorPosition) === "right") {
      leaf = this.app.workspace.getRightLeaf(false);
    } else if (((_c = this.settings) == null ? void 0 : _c.editorPosition) === "left") {
      leaf = this.app.workspace.getLeftLeaf(false);
    } else if (((_d = this.settings) == null ? void 0 : _d.editorPosition) === "modal") {
      leaf = this.app.workspace.getLeaf(false);
    } else {
      leaf = this.app.workspace.getRightLeaf(false);
    }
    await leaf.setViewState({
      type: viewType,
      active: true,
      state
    });
    this.app.workspace.revealLeaf(
      leaf
    );
    return leaf;
  }
  // TODO: extract the migration logic to a separate function and test it
  // TODO: collect actual migration events to decide if we need to migrate or not rather than this naive approach
  async getSettings() {
    const data = await this.loadData();
    const [migrationIsNeeded, settings2] = pipe(
      parseSettings(data),
      map((settings3) => {
        const migrationIsNeeded2 = settings3.formDefinitions.some(formNeedsMigration);
        const { right: formDefinitions, left: errors } = partitionMap(migrateToLatest)(settings3.formDefinitions);
        notifyParsingErrors(errors);
        const validSettings = { ...settings3, formDefinitions };
        return [migrationIsNeeded2, validSettings];
      }),
      getOrElse(() => [false, getDefaultSettings()])
    );
    if (migrationIsNeeded) {
      await this.saveSettings(settings2);
      console.info("Settings were migrated to the latest version");
    }
    return settings2;
  }
  async saveSettings(newSettings) {
    await this.saveData(newSettings || this.settings);
  }
  async setEditorPosition(position) {
    this.settings.editorPosition = position;
    await this.saveSettings();
  }
  async onload() {
    const settings2 = await this.getSettings();
    if (settings2.formDefinitions.length === 0) {
      settings2.formDefinitions.push(exampleModalDefinition);
    }
    settingsStore.set(settings2);
    this.unsubscribeSettingsStore = settingsStore.subscribe((s) => {
      console.log("settings changed", s);
      this.settings = s;
      this.saveSettings(s);
    });
    this.api = new API(this.app, this);
    this.registerView(EDIT_FORM_VIEW, (leaf) => new EditFormView(leaf, this));
    this.registerView(MANAGE_FORMS_VIEW, (leaf) => new ManageFormsView(leaf, this));
    this.addRibbonIcon(
      "documents",
      "Edit forms",
      (evt) => {
        this.manageForms();
      }
    );
    this.addCommand({
      id: "new-form",
      name: "New form",
      callback: () => {
        this.createNewForm();
      }
    });
    this.addCommand({
      id: "manage-forms",
      name: "Manage forms",
      callback: () => {
        this.manageForms();
      }
    });
    this.addSettingTab(new ModalFormSettingTab(this.app, this));
  }
};
